{"task_id": "HumanEval/0", "completion": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False"}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string):\n    open_brace = 0\n    start_index = 0\n    result = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if open_brace == 0:\n                start_index = i\n            open_brace += 1\n        elif char == ')':\n            open_brace -= 1\n            if open_brace == 0:\n                result.append(paren_string[start_index:i+1])\n    return result"}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number % 1"}
{"task_id": "HumanEval/3", "completion": "def below_zero(operations: List[int]) -> bool:\n    return any(operation < 0 for operation in operations)"}
{"task_id": "HumanEval/4", "completion": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum([abs(x - mean) for x in numbers]) / len(numbers)"}
{"task_id": "HumanEval/5", "completion": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    return [x for pair in zip(numbers[::2], numbers[1::2]) for x in pair] + numbers[-1:]"}
{"task_id": "HumanEval/6", "completion": "def parse_nested_parens(paren_string: str) -> List[int]:\n    def parse_parens(s: str) -> int:\n        level = 0\n        max_level = 0\n        for c in s:\n            if c == '(':\n                level += 1\n                max_level = max(max_level, level)\n            elif c == ')':\n                level -= 1\n        return max_level\n\n    return [parse_parens(s) for s in paren_string.split()]"}
{"task_id": "HumanEval/7", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \"\"\"\n    return sum(numbers), math.prod(numbers) if numbers else 1"}
{"task_id": "HumanEval/9", "completion": "def rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n    \"\"\"\n    max_value = 0\n    result = []\n    for num in numbers:\n        if num > max_value:\n            max_value = num\n        result.append(max_value)\n    return result"}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\"Test if given string is a palindrome\"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if not string or len(string) == 1:\n        return string\n\n    # find the longest postfix of supplied string that is a palindrome\n    postfix_start = 0\n    for i in range(len(string) - 1, 0, -1):\n        if is_palindrome(string[i:]):\n            postfix_start = i\n            break\n\n    # append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return string + string[postfix_start:len(string) - 1][::-1]"}
{"task_id": "HumanEval/11", "completion": "def string_xor(a: str, b: str) -> str:\n    return bin(int(a, 2) ^ int(b, 2))[2:].rjust(len(a), '0')"}
{"task_id": "HumanEval/12", "completion": "def longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)"}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a, b):\n    while b:\n        a, b = b, a % b\n    return a"}
{"task_id": "HumanEval/14", "completion": "def all_prefixes(string: str) -> List[str]:\n    return [string[:i+1] for i in range(len(string))]"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    return \" \".join(map(str, range(1, n+1)))"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    return len(set(string))"}
{"task_id": "HumanEval/17", "completion": "def parse_music(music_string: str) -> List[int]:\n    note_map = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    return [note_map[note] for note in music_string.split()]"}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string, substring):\n    return sum(1 for i in range(len(string) - len(substring) + 1) if string[i:i+len(substring)] == substring)"}
{"task_id": "HumanEval/19", "completion": "def sort_numbers(numbers: str) -> str:\n    number_list = numbers.split()\n    sorted_numbers = sorted(number_list, key=lambda x: int(x))\n    return \" \".join(sorted_numbers)"}
{"task_id": "HumanEval/20", "completion": "def find_closest_elements(numbers):\n    numbers.sort()\n    smallest_diff = float('inf')\n    closest_pair = []\n\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[j] - numbers[i])\n            if diff < smallest_diff:\n                smallest_diff = diff\n                closest_pair = [numbers[i], numbers[j]]\n\n    return closest_pair"}
{"task_id": "HumanEval/21", "completion": "def rescale_to_unit(numbers):\n    \"\"\"\n    Given a list of numbers, apply a linear transform to the list\n    such that the smallest number will become 0 and the largest will become 1.\n    \"\"\"\n    low = min(numbers)\n    high = max(numbers)\n    return [(x - low) / (high - low) for x in numbers]"}
{"task_id": "HumanEval/22", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/23", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n):\n    for i in range(n, 0, -1):\n        if n % i == 0:\n            return i"}
{"task_id": "HumanEval/25", "completion": "def factorize(n: int) -> List[int]:\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 2:\n        factors.append(n)\n    return factors"}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    return list(dict.fromkeys(numbers))"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    return ''.join([c.lower() if c.isupper() else c.upper() for c in string])"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    return \"\".join(strings)"}
{"task_id": "HumanEval/29", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/30", "completion": "def get_positive(my_list):\n    return list(filter(lambda x: x > 0, my_list))"}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/32", "completion": "def find_zero(xs: list):\n    \"\"\"\n    Finds a zero of the polynomial defined by the given coefficients xs.\n    The function returns only one zero, even if multiple zeros exist.\n    The function only takes lists xs with an even number of coefficients and the largest non-zero coefficient, which guarantees a solution.\n    \"\"\"\n    # Implement the find_zero function here\n    return 0"}
{"task_id": "HumanEval/33", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [-cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second)\n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/34", "completion": "def unique(my_list):\n    return list(set(my_list))"}
{"task_id": "HumanEval/35", "completion": "def max_element(my_list):\n    return max(my_list)"}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n+1):\n        if i % 15 == 0:\n            if '7' in str(i):\n                count += 1\n    return count"}
{"task_id": "HumanEval/37", "completion": "def sort_even(l):\n    return sorted(l[1::2]) + l[::2]"}
{"task_id": "HumanEval/38", "completion": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1:] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"task_id": "HumanEval/39", "completion": "def prime_fib(n: int) -> int:\n    fib_seq = []\n    curr_fib, next_fib = 1, 1\n    for _ in range(n):\n        if is_prime(curr_fib):\n            fib_seq.append(curr_fib)\n        curr_fib, next_fib = next_fib, curr_fib + next_fib\n    return fib_seq[-1]\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(my_list):\n    for i in range(len(my_list)):\n        for j in range(i+1, len(my_list)):\n            for k in range(j+1, len(my_list)):\n                if my_list[i] + my_list[j] + my_list[k] == 0:\n                    return True\n    return False"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    # Calculate the number of collisions\n    collisions = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            elif i < j:\n                collisions += 1\n    return collisions"}
{"task_id": "HumanEval/42", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(my_list):\n    return any(my_list[i] + my_list[j] == 0 for i in range(len(my_list)) for j in range(i+1, len(my_list)))"}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int) -> str:\n    \"\"\"Change numerical base of input number x to base.\n    Return string representation after the conversion.\n    Base numbers are less than 10.\n    \"\"\"\n    return bin(x)[2:].zfill(base)"}
{"task_id": "HumanEval/45", "completion": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [-cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second)\n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int) -> int:\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    \"\"\"\n    if n <= 3:\n        return 0\n    elif n == 4:\n        return 2\n    \n    # Initialize the first four elements of the sequence\n    a, b, c, d = 0, 0, 2, 0\n    \n    for i in range(5, n+1):\n        # Compute the next element in the sequence using the previous four elements\n        a, b, c, d = b, c, d, a + b + c + d\n    \n    return d"}
{"task_id": "HumanEval/47", "completion": "def median(l):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return sorted(l)[len(l) // 2] if len(l) % 2 else (sorted(l)[len(l) // 2 - 1] + sorted(l)[len(l) // 2]) / 2"}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n\n    :param text: The string to check\n    :return: True if the string is a palindrome, False otherwise\n    \"\"\"\n    return all(text[i] == text[-i-1] for i in range(len(text)//2))"}
{"task_id": "HumanEval/49", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    vowels = set('aeiou')\n    return ''.join([char for char in text if char.lower() not in vowels])"}
{"task_id": "HumanEval/52", "completion": "def below_threshold(my_list, threshold):\n    return all(element < threshold for element in my_list)"}
{"task_id": "HumanEval/53", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    scount = Counter(nums)\n    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    \n    \n    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2"}
{"task_id": "HumanEval/54", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/55", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    scount = Counter(nums)\n    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    \n    \n    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Returns True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    stack = []\n    for char in brackets:\n        if char == \"<\":\n            stack.append(char)\n        elif char == \">\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    \"\"\"\n    if len(l) <= 1:\n        return True\n    return all(l[i] >= l[i-1] for i in range(1, len(l))) or all(l[i] <= l[i-1] for i in range(1, len(l)))"}
{"task_id": "HumanEval/58", "completion": "def common(l1, l2):\n    return list(set(l1) & set(l2))"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n):\n    if n <= 1:\n        return n\n    for i in range(int(n**0.5), 1, -1):\n        if n % i == 0 and is_prime(i):\n            return i\n    return 1\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/60", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    scount = Counter(nums)\n    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    \n    \n    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2"}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Returns True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    stack = []\n    for char in brackets:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs):\n    if len(xs) == 1:\n        return [0]\n    else:\n        return [i * xs[i] for i in range(1, len(xs))]"}
{"task_id": "HumanEval/63", "completion": "def fibfib(n):\n    if n <= 2:\n        return 0\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)"}
{"task_id": "HumanEval/64", "completion": "def vowels_count(word):\n    return sum(map(str.lower, word).count(v) for v in 'aeiou')"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[-shift:] + s[:-shift]"}
{"task_id": "HumanEval/66", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/67", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    if not arr:\n        return []\n    even_values = [x for x in arr if x % 2 == 0]\n    if not even_values:\n        return []\n    smallest_even_value = min(even_values)\n    smallest_even_index = arr.index(smallest_even_value)\n    return [smallest_even_value, smallest_even_index]"}
{"task_id": "HumanEval/69", "completion": "def search(lst):\n    # create a dictionary to store the count of each integer\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # find the maximum integer that satisfies the condition\n    max_int = -1\n    for num, count in freq.items():\n        if num > 0 and count >= num and num > max_int:\n            max_int = num\n\n    return max_int"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    return sorted(lst, key=lambda x: (x % 2, x))"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    if a + b > c and b + c > a and a + c > b:\n        area = (a * b * c) / 2\n        return round(area, 2)\n    else:\n        return -1"}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n    return all(q[i] == q[-i-1] for i in range(len(q))) and sum(q) <= w"}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n    mid = len(arr) // 2\n    changes = 0\n    for i in range(mid):\n        if arr[i] != arr[len-i-1]:\n            changes += 1\n            arr[i] = arr[len-i-1]\n    return changes"}
{"task_id": "HumanEval/74", "completion": "def total_match(list1, list2):\n    total_chars1 = sum(len(s) for s in list1)\n    total_chars2 = sum(len(s) for s in list2)\n    return list1 if total_chars1 < total_chars2 else list2"}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a):\n    if a < 1:\n        return False\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0 and is_prime(i) and is_prime(a//i):\n            return True\n    return False\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n    return x == n ** (x // n)"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    return a**(1/3) % 1 == 0"}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    prime_digits = {2, 3, 5, 7, 11, 13, 17, 19}\n    num = num.upper()\n    count = 0\n    for char in num:\n        if char in 'ABCDEF' and int(char, 16) in prime_digits:\n            count += 1\n    return count"}
{"task_id": "HumanEval/79", "completion": "def minLengthAfterRemovals(nums):\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    return len(s) >= 3 and all(s[i] != s[i+1] != s[i+2] for i in range(len(s) - 2))"}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n    return ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'D+', 'D', 'D-', 'E'][min(12, max(0, (int(grade - 3) / 2)))] for grade in grades]"}
{"task_id": "HumanEval/82", "completion": "def prime_length(string):\n    return len(string) in {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    return len([i for i in range(10**(n-1), 10**n) if str(i)[0] == '1' or str(i)[-1] == '1'])"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    return len(str(bin(N)[2:]))"}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 and not x % 2)"}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    words = s.split()\n    return \" \".join(sorted(words, key=lambda x: \"\".join(sorted(x))))"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    return sorted([(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x], key=lambda x: (x[0], -x[1]))"}
{"task_id": "HumanEval/88", "completion": "def sort_array(arr):\n    if sum(arr[0], arr[-1]) % 2 == 0:\n        return sorted(arr, reverse=True)\n    else:\n        return sorted(arr)"}
{"task_id": "HumanEval/89", "completion": "def encrypt(s):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    new_alphabet = alphabet[2:] + alphabet[:2]\n    table = str.maketrans(alphabet, new_alphabet)\n    return s.translate(table)"}
{"task_id": "HumanEval/90", "completion": "def next_smallest(my_list):\n    return min(my_list[1:], default=None)"}
{"task_id": "HumanEval/91", "completion": "def is_bored(string):\n    return sum(1 for sentence in string.split('.')[:-1] if sentence.startswith('I'))"}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n    return (x == y + z) or (y == x + z) or (z == x + y)"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    encoded = ''\n    for char in message:\n        if char.isalpha():\n            encoded += chr(ord(char) + 1) if char.islower() else chr(ord(char) - 1)\n        else:\n            encoded += char\n    \n    for i, char in enumerate(encoded):\n        if char in vowels:\n            encoded = encoded[:i] + chr(ord(char) + 2) + encoded[i+1:]\n    \n    return encoded"}
{"task_id": "HumanEval/94", "completion": "def get_largest_prime_sum(my_list):\n    largest_prime = max(my_list, key=is_prime)\n    if largest_prime:\n        return sum(int(digit) for digit in str(largest_prime))\n    else:\n        return 0\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(my_dict):\n    if not my_dict:\n        return False\n    first_key = list(my_dict.keys())[0]\n    return all(key.islower() or key.isupper() for key in my_dict.keys())"}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    prime_numbers = []\n    for i in range(2, n+1):\n        if all(i % j != 0 for j in range(2, int(i**0.5) + 1)):\n            prime_numbers.append(i)\n    return prime_numbers"}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n    return a * b"}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n    return sum(c.isupper() for i, c in enumerate(s) if i % 2 == 0)"}
{"task_id": "HumanEval/99", "completion": "def closest_integer(value):\n    return int(round(float(value)))"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    stones = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = (n + 1) // 2\n        stones.append(n)\n    return stones[::-1]"}
{"task_id": "HumanEval/101", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n    # find the biggest even number in the range [x, y] inclusive\n    for i in range(y, x-1, -1):\n        if i % 2 == 0:\n            return i\n    return -1"}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    sum = 0\n    for i in range(n, m+1):\n        sum += i\n    average = int(sum / (m-n+1))\n    binary_string = bin(average)[2:]\n    return \"0b\" + binary_string"}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n    return sorted(i for i in x if not any(int(digit) % 2 == 0 for digit in str(i)))"}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    arr.sort()\n    arr.reverse()\n    return [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][arr]"}
{"task_id": "HumanEval/106", "completion": "def f(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            sum = 0\n            for j in range(1, i+1):\n                sum += j\n            result.append(sum)\n    return result"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n+1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    return len([num for num in arr if sum(map(int, str(num))) > 0])"}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n    if not arr:\n        return True\n    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True"}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n    # Check if all elements in lst1 are even\n    if all(x % 2 == 0 for x in lst1):\n        return \"YES\"\n    # Check if there are any even numbers in lst2\n    elif any(x % 2 == 0 for x in lst2):\n        return \"NO\"\n    # Check if it is possible to exchange elements between lst1 and lst2 to make all elements of lst1 even\n    else:\n        # Sort both lists\n        lst1.sort()\n        lst2.sort()\n        # Initialize variables to keep track of the current index in both lists\n        i = 0\n        j = 0\n        # Loop through both lists and check if it is possible to exchange elements to make all elements of lst1 even\n        while i < len(lst1) and j < len(lst2):\n            if lst1[i] % 2 == 0 and lst2[j] % 2 != 0:\n                # If the current element in lst1 is even and the current element in lst2 is odd, exchange elements\n                lst1[i], lst2[j] = lst2[j], lst1[i]\n                i += 1\n                j += 1\n            elif lst1[i] % 2 != 0 and lst2[j] % 2 == 0:\n                # If the current element in lst1 is odd and the current element in lst2 is even, exchange elements\n                lst1[i], lst2[j] = lst2[j], lst1[i]\n                i += 1\n                j += 1\n            else:\n                # If the current elements in both lists are not compatible for exchange, move on to the next element in lst1\n                i += 1\n        # After looping through both lists, check if all elements of lst1 are even\n        if all(x % 2 == 0 for x in lst1):\n            return \"YES\"\n        else:\n            return \"NO\""}
{"task_id": "HumanEval/111", "completion": "def histogram(string):\n    return {letter: string.count(letter) for letter in set(string)}"}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    result = \"\"\n    for char in s:\n        if char not in c:\n            result += char\n    return (result, result == result[::-1])"}
{"task_id": "HumanEval/113", "completion": "def odd_count(my_list):\n    return sum(int(x) % 2 == 1 for x in s) for s in my_list"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    min_sum = float('inf')\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            min_sum = min(min_sum, current_sum)\n    return min_sum"}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n    rows = len(grid)\n    cols = len(grid[0])\n    water = 0\n    buckets = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                water += 1\n                if water == capacity:\n                    buckets += 1\n                    water = 0\n\n    if water > 0:\n        buckets += 1\n\n    return buckets"}
{"task_id": "HumanEval/116", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/117", "completion": "def select_words(s, n):\n    return [word for word in s.split() if len(word) == n]"}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    vowels = \"aeiou\"\n    for i in range(len(word)-1, 0, -1):\n        if word[i] in vowels:\n            return word[i]\n    return \"\""}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    open_count = 0\n    for char in lst:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            open_count -= 1\n        if open_count < 0:\n            return 'No'\n    return 'Yes' if open_count == 0 else 'No'"}
{"task_id": "HumanEval/120", "completion": "def maximum(arr, k):\n    return sorted(arr, reverse=True)[:k]"}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)"}
{"task_id": "HumanEval/122", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    if n <= 0:\n        raise ValueError(\"n should be a positive integer.\")\n    \n    collatz_list = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n        collatz_list.append(n)\n    \n    return sorted([x for x in collatz_list if x % 2 != 0])"}
{"task_id": "HumanEval/124", "completion": "def valid_date(date):\n    \"\"\"\n    Validates a given date string and returns True if the date is valid, otherwise False.\n\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n    \"\"\"\n    if not date:\n        return False\n    match = re.match(r'^(\\d{2})-(\\d{2})-(\\d{4})$', date)\n    if not match:\n        return False\n    month, day, year = map(int, match.groups())\n    if month < 1 or month > 12:\n        return False\n    if day < 1 or day > 31:\n        return False\n    if month in [4, 6, 9, 11] and day == 31:\n        return False\n    if month == 2 and (day < 1 or day > 29):\n        return False\n    if year % 4 == 0 and month == 2 and day == 30:\n        return False\n    return True"}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        result = 0\n        for char in txt:\n            if ord(char) % 2 == 1:\n                result += 1\n        return result"}
{"task_id": "HumanEval/126", "completion": "def is_sorted(my_list):\n    return all(my_list[i] <= my_list[i + 1] for i in range(len(my_list) - 1))"}
{"task_id": "HumanEval/127", "completion": "def intersection(interval1, interval2):\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return \"NO\"\n    length = end - start + 1\n    if length > 1 and all(length % i != 0 for i in range(2, int(length ** 0.5) + 1)):\n        return \"YES\"\n    return \"NO\""}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n    if not arr:\n        return None\n    mult = 1\n    for num in arr:\n        if num < 0:\n            mult *= -1\n    return sum(abs(num) * mult for num in arr)"}
{"task_id": "HumanEval/129", "completion": "import heapq\n\ndef min_path(grid, k):\n    # Initialize the heap with the first element of each row\n    heap = [(grid[0][0], 0, 0)]\n    # Initialize the visited matrix with False\n    visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\n    # Initialize the result list\n    result = []\n\n    while len(heap) > 0:\n        # Pop the smallest element from the heap\n        value, row, col = heapq.heappop(heap)\n        # If the current position is not visited and the path length is less than k\n        if not visited[row][col] and len(result) < k:\n            # Add the current value to the result list\n            result.append(value)\n            # Mark the current position as visited\n            visited[row][col] = True\n            # Loop through the neighbors of the current position\n            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                # If the neighbor is within the grid and not visited\n                if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and not visited[r][c]:\n                    # Add the neighbor to the heap\n                    heapq.heappush(heap, (grid[r][c], r, c))\n\n    return result\n\ndef main():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    k = 3\n    print(min_path(grid, k))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/130", "completion": "def tribonacci_sequence(n):\n    if n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 3]\n    else:\n        seq = [1, 3]\n        for i in range(2, n):\n            seq.append(seq[i-1] + seq[i-2] + seq[i+1])\n        return seq"}
{"task_id": "HumanEval/131", "completion": "def digits(n):\n    return product(int(i) for i in str(n) if int(i) % 2 == 1)"}
{"task_id": "HumanEval/132", "completion": "def is_nested(s):\n    stack = []\n    for char in s:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return bool(stack)"}
{"task_id": "HumanEval/133", "completion": "def sum_squares(my_list):\n    return sum(int(x)**2 for x in my_list)"}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n    return txt and txt[-1].isalpha() and txt[-1] not in \"abcdefghijklmnopqrstuvwxyz\""}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] <= arr[i - 1]:\n            return i\n    return -1"}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    return (max(filter(lambda x: x < 0, lst), default=None), min(filter(lambda x: x > 0, lst), default=None))"}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n    if isinstance(a, str):\n        a = float(a.replace(\",\", \".\"))\n    if isinstance(b, str):\n        b = float(b.replace(\",\", \".\"))\n    return a if a > b else b"}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n    return n % 2 == 0 and any(n == i + j + k + l for i in range(2, int(n**0.5) + 1, 2) for j in range(2, int(n**0.5) + 1, 2) for k in range(2, int(n**0.5) + 1, 2) for l in range(2, int(n**0.5) + 1, 2))"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    return n * special_factorial(n-1) if n > 1 else 1"}
{"task_id": "HumanEval/140", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/141", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [-cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second)\n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n    result = 0\n    for i, x in enumerate(lst):\n        if i % 3 == 0:\n            result += x * x\n        elif i % 4 == 0:\n            result += x * x * x\n        else:\n            result += x\n    return result"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    return \" \".join([word for word in sentence.split() if is_prime(len(word))])\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/144", "completion": "def simplify(x, n):\n    x_num, x_denom = map(int, x.split(\"/\"))\n    n_num, n_denom = map(int, n.split(\"/\"))\n    return (x_num * n_num) % (x_denom * n_denom) == 0"}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    return sorted(nums, key=lambda x: (sum(int(digit) for digit in str(abs(x))), x))"}
{"task_id": "HumanEval/146", "completion": "def special_filter(nums):\n    return sum(num > 10 and num % 10 in [1, 3, 5, 7, 9] and num // 100 in [1, 3, 5, 7, 9] for num in nums)"}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if a[i] + a[j] + a[k] % 3 == 0:\n                    count += 1\n    return count"}
{"task_id": "HumanEval/148", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/149", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/150", "completion": "def x_or_y(n, x, y):\n    return x if is_prime(n) else y\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    return sum(x**2 for x in lst if x % 2 != 0 and x > 0 and x == int(x))"}
{"task_id": "HumanEval/152", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/153", "completion": "def strongest_extension(class_name, extensions):\n    return max(extensions, key=lambda ext: sum(1 for c in ext if c.isupper()) - sum(1 for c in ext if c.islower()))"}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(word1, word2):\n    return any(word2 in word1[i:] for i in range(len(word1)))"}
{"task_id": "HumanEval/155", "completion": "def minLengthAfterRemovals(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [ -cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second) \n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    num = str(number)\n    roman = ''\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    for i in range(len(values)):\n        while num[0] == '1':\n            roman += numerals[i]\n            num = num[1:]\n        if num[0] == '0':\n            num = num[1:]\n    return roman"}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a, b, c):\n    return any([(a**2 + b**2 == c**2), (b**2 + c**2 == a**2), (c**2 + a**2 == b**2)])"}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n    if not words:\n        return None\n    return max(words, key=lambda x: (len(set(x)), x))"}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    return [min(remaining, number + need), max(0, remaining - (number + need))]"}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operator, operand):\n    result = operand[0]\n    for i in range(len(operator)):\n        op = operator[i]\n        if op == '+':\n            result += operand[i+1]\n        elif op == '-':\n            result -= operand[i+1]\n        elif op == '*':\n            result *= operand[i+1]\n        elif op == '//':\n            result //= operand[i+1]\n        elif op == '**':\n            result **= operand[i+1]\n        else:\n            raise ValueError(\"Invalid operator\")\n    return result"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    return \"\".join([c.upper() if c.islower() else c.lower() for c in s]) or s[::-1]"}
{"task_id": "HumanEval/162", "completion": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    counter = Counter(nums)\n    heap = [-cnt for cnt in counter.values()]\n    heapify(heap)\n    while len(heap) > 1:\n        largest = -heappop(heap)\n        second = -heappop(heap)\n        if largest > 1:\n            heappush(heap, 1-largest)\n        if second > 1:\n            heappush(heap, 1-second)\n    return -heap[0] if heap else 0"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if i % 2 == 0]"}
