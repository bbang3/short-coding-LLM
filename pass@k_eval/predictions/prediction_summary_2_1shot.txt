HumanEval/0

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if abs(numbers[i] - numbers[j]) <= threshold:
                return True
    return False

--------------------------------------------------
HumanEval/1

def separate_paren_groups(paren_string):
    open_brace = 0
    start_index = 0
    result = []
    for i, char in enumerate(paren_string):
        if char == '(':
            if open_brace == 0:
                start_index = i
            open_brace += 1
        elif char == ')':
            open_brace -= 1
            if open_brace == 0:
                result.append(paren_string[start_index:i+1])
    return result

--------------------------------------------------
HumanEval/2

def truncate_number(number: float) -> float:
    """ Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    >>> truncate_number(3.5)
    0.5
    """
    return number % 1

--------------------------------------------------
HumanEval/3

def below_zero(operations: List[int]) -> bool:
    return any(operation < 0 for operation in operations)

--------------------------------------------------
HumanEval/4

def mean_absolute_deviation(numbers: List[float]) -> float:
    mean = sum(numbers) / len(numbers)
    return sum([abs(x - mean) for x in numbers]) / len(numbers)

--------------------------------------------------
HumanEval/5

def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    return [x for pair in zip(numbers[::2], numbers[1::2]) for x in pair] + numbers[-1:]

--------------------------------------------------
HumanEval/6

def parse_nested_parens(paren_string: str) -> List[int]:
    def parse_parens(s: str) -> int:
        level = 0
        max_level = 0
        for c in s:
            if c == '(':
                level += 1
                max_level = max(max_level, level)
            elif c == ')':
                level -= 1
        return max_level

    return [parse_parens(s) for s in paren_string.split()]

--------------------------------------------------
HumanEval/7

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/8

def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """
    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    """
    return sum(numbers), math.prod(numbers) if numbers else 1

--------------------------------------------------
HumanEval/9

def rolling_max(numbers: List[int]) -> List[int]:
    """
    Given a list of integers, generate a list of rolling maximum element found until given moment in the sequence.
    """
    max_value = 0
    result = []
    for num in numbers:
        if num > max_value:
            max_value = num
        result.append(max_value)
    return result

--------------------------------------------------
HumanEval/10

def is_palindrome(string: str) -> bool:
    """Test if given string is a palindrome"""
    return string == string[::-1]

def make_palindrome(string: str) -> str:
    """Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    """
    if not string or len(string) == 1:
        return string

    # find the longest postfix of supplied string that is a palindrome
    postfix_start = 0
    for i in range(len(string) - 1, 0, -1):
        if is_palindrome(string[i:]):
            postfix_start = i
            break

    # append to the end of the string reverse of a string prefix that comes before the palindromic suffix
    return string + string[postfix_start:len(string) - 1][::-1]

--------------------------------------------------
HumanEval/11

def string_xor(a: str, b: str) -> str:
    return bin(int(a, 2) ^ int(b, 2))[2:].rjust(len(a), '0')

--------------------------------------------------
HumanEval/12

def longest(strings: List[str]) -> Optional[str]:
    if not strings:
        return None
    return max(strings, key=len)

--------------------------------------------------
HumanEval/13

def greatest_common_divisor(a, b):
    while b:
        a, b = b, a % b
    return a

--------------------------------------------------
HumanEval/14

def all_prefixes(string: str) -> List[str]:
    return [string[:i+1] for i in range(len(string))]

--------------------------------------------------
HumanEval/15

def string_sequence(n: int) -> str:
    return " ".join(map(str, range(1, n+1)))

--------------------------------------------------
HumanEval/16

def count_distinct_characters(string: str) -> int:
    return len(set(string))

--------------------------------------------------
HumanEval/17

def parse_music(music_string: str) -> List[int]:
    note_map = {
        'o': 4,
        'o|': 2,
        '.|': 1
    }
    return [note_map[note] for note in music_string.split()]

--------------------------------------------------
HumanEval/18

def how_many_times(string, substring):
    return sum(1 for i in range(len(string) - len(substring) + 1) if string[i:i+len(substring)] == substring)

--------------------------------------------------
HumanEval/19

def sort_numbers(numbers: str) -> str:
    number_list = numbers.split()
    sorted_numbers = sorted(number_list, key=lambda x: int(x))
    return " ".join(sorted_numbers)

--------------------------------------------------
HumanEval/20

def find_closest_elements(numbers):
    numbers.sort()
    smallest_diff = float('inf')
    closest_pair = []

    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            diff = abs(numbers[j] - numbers[i])
            if diff < smallest_diff:
                smallest_diff = diff
                closest_pair = [numbers[i], numbers[j]]

    return closest_pair

--------------------------------------------------
HumanEval/21

def rescale_to_unit(numbers):
    """
    Given a list of numbers, apply a linear transform to the list
    such that the smallest number will become 0 and the largest will become 1.
    """
    low = min(numbers)
    high = max(numbers)
    return [(x - low) / (high - low) for x in numbers]

--------------------------------------------------
HumanEval/22

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/23

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/24

def largest_divisor(n):
    for i in range(n, 0, -1):
        if n % i == 0:
            return i

--------------------------------------------------
HumanEval/25

def factorize(n: int) -> List[int]:
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:
        factors.append(n)
    return factors

--------------------------------------------------
HumanEval/26

def remove_duplicates(numbers: List[int]) -> List[int]:
    return list(dict.fromkeys(numbers))

--------------------------------------------------
HumanEval/27

def flip_case(string: str) -> str:
    return ''.join([c.lower() if c.isupper() else c.upper() for c in string])

--------------------------------------------------
HumanEval/28

def concatenate(strings: List[str]) -> str:
    return "".join(strings)

--------------------------------------------------
HumanEval/29

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/30

def get_positive(my_list):
    return list(filter(lambda x: x > 0, my_list))

--------------------------------------------------
HumanEval/31

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/32

def find_zero(xs: list):
    """
    Finds a zero of the polynomial defined by the given coefficients xs.
    The function returns only one zero, even if multiple zeros exist.
    The function only takes lists xs with an even number of coefficients and the largest non-zero coefficient, which guarantees a solution.
    """
    # Implement the find_zero function here
    return 0

--------------------------------------------------
HumanEval/33

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [-cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second)
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/34

def unique(my_list):
    return list(set(my_list))

--------------------------------------------------
HumanEval/35

def max_element(my_list):
    return max(my_list)

--------------------------------------------------
HumanEval/36

def fizz_buzz(n: int) -> int:
    count = 0
    for i in range(1, n+1):
        if i % 15 == 0:
            if '7' in str(i):
                count += 1
    return count

--------------------------------------------------
HumanEval/37

def sort_even(l):
    return sorted(l[1::2]) + l[::2]

--------------------------------------------------
HumanEval/38

def decode_cyclic(s: str):
    """
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[-1:] + group[:-1]) if len(group) == 3 else group for group in groups]
    return "".join(groups)

--------------------------------------------------
HumanEval/39

def prime_fib(n: int) -> int:
    fib_seq = []
    curr_fib, next_fib = 1, 1
    for _ in range(n):
        if is_prime(curr_fib):
            fib_seq.append(curr_fib)
        curr_fib, next_fib = next_fib, curr_fib + next_fib
    return fib_seq[-1]

def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/40

def triples_sum_to_zero(my_list):
    for i in range(len(my_list)):
        for j in range(i+1, len(my_list)):
            for k in range(j+1, len(my_list)):
                if my_list[i] + my_list[j] + my_list[k] == 0:
                    return True
    return False

--------------------------------------------------
HumanEval/41

def car_race_collision(n: int) -> int:
    """
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """
    # Calculate the number of collisions
    collisions = 0
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            elif i < j:
                collisions += 1
    return collisions

--------------------------------------------------
HumanEval/42

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/43

def pairs_sum_to_zero(my_list):
    return any(my_list[i] + my_list[j] == 0 for i in range(len(my_list)) for j in range(i+1, len(my_list)))

--------------------------------------------------
HumanEval/44

def change_base(x: int, base: int) -> str:
    """Change numerical base of input number x to base.
    Return string representation after the conversion.
    Base numbers are less than 10.
    """
    return bin(x)[2:].zfill(base)

--------------------------------------------------
HumanEval/45

def minLengthAfterRemovals(nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [-cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second)
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/46

def fib4(n: int) -> int:
    """The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fib4(0) -> 0
    fib4(1) -> 0
    fib4(2) -> 2
    fib4(3) -> 0
    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
    """
    if n <= 3:
        return 0
    elif n == 4:
        return 2
    
    # Initialize the first four elements of the sequence
    a, b, c, d = 0, 0, 2, 0
    
    for i in range(5, n+1):
        # Compute the next element in the sequence using the previous four elements
        a, b, c, d = b, c, d, a + b + c + d
    
    return d

--------------------------------------------------
HumanEval/47

def median(l):
    """Return median of elements in the list l.
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """
    return sorted(l)[len(l) // 2] if len(l) % 2 else (sorted(l)[len(l) // 2 - 1] + sorted(l)[len(l) // 2]) / 2

--------------------------------------------------
HumanEval/48

def is_palindrome(text: str) -> bool:
    """
    Checks if given string is a palindrome

    :param text: The string to check
    :return: True if the string is a palindrome, False otherwise
    """
    return all(text[i] == text[-i-1] for i in range(len(text)//2))

--------------------------------------------------
HumanEval/49

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/50

def decode_shift(s: str):
    """
    takes as input string encoded with encode_shift function. Returns decoded string.
    """
    return "".join([chr(((ord(ch) - 5 - ord("a")) % 26) + ord("a")) for ch in s])

--------------------------------------------------
HumanEval/51

def remove_vowels(text):
    vowels = set('aeiou')
    return ''.join([char for char in text if char.lower() not in vowels])

--------------------------------------------------
HumanEval/52

def below_threshold(my_list, threshold):
    return all(element < threshold for element in my_list)

--------------------------------------------------
HumanEval/53

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/54

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/55

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/56

def correct_bracketing(brackets: str) -> bool:
    """
    Returns True if every opening bracket has a corresponding closing bracket.
    """
    stack = []
    for char in brackets:
        if char == "<":
            stack.append(char)
        elif char == ">":
            if len(stack) == 0:
                return False
            stack.pop()
    return len(stack) == 0

--------------------------------------------------
HumanEval/57

def monotonic(l):
    """Return True is list elements are monotonically increasing or decreasing.
    """
    if len(l) <= 1:
        return True
    return all(l[i] >= l[i-1] for i in range(1, len(l))) or all(l[i] <= l[i-1] for i in range(1, len(l)))

--------------------------------------------------
HumanEval/58

def common(l1, l2):
    return list(set(l1) & set(l2))

--------------------------------------------------
HumanEval/59

def largest_prime_factor(n):
    if n <= 1:
        return n
    for i in range(int(n**0.5), 1, -1):
        if n % i == 0 and is_prime(i):
            return i
    return 1

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/60

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/61

def correct_bracketing(brackets: str) -> bool:
    """
    Returns True if every opening bracket has a corresponding closing bracket.
    """
    stack = []
    for char in brackets:
        if char == "(":
            stack.append(char)
        elif char == ")":
            if not stack:
                return False
            stack.pop()
    return not stack

--------------------------------------------------
HumanEval/62

def derivative(xs):
    if len(xs) == 1:
        return [0]
    else:
        return [i * xs[i] for i in range(1, len(xs))]

--------------------------------------------------
HumanEval/63

def fibfib(n):
    if n <= 2:
        return 0
    else:
        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)

--------------------------------------------------
HumanEval/64

def vowels_count(word):
    return sum(map(str.lower, word).count(v) for v in 'aeiou')

--------------------------------------------------
HumanEval/65

def circular_shift(x, shift):
    """Circular shift the digits of the integer x, shift the digits right by shift
    and return the result as a string.
    If shift > number of digits, return digits reversed.
    >>> circular_shift(12, 1)
    "21"
    >>> circular_shift(12, 2)
    "12"
    """
    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[-shift:] + s[:-shift]

--------------------------------------------------
HumanEval/66

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/67

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/68

def pluck(arr):
    if not arr:
        return []
    even_values = [x for x in arr if x % 2 == 0]
    if not even_values:
        return []
    smallest_even_value = min(even_values)
    smallest_even_index = arr.index(smallest_even_value)
    return [smallest_even_value, smallest_even_index]

--------------------------------------------------
HumanEval/69

def search(lst):
    # create a dictionary to store the count of each integer
    freq = {}
    for num in lst:
        if num in freq:
            freq[num] += 1
        else:
            freq[num] = 1

    # find the maximum integer that satisfies the condition
    max_int = -1
    for num, count in freq.items():
        if num > 0 and count >= num and num > max_int:
            max_int = num

    return max_int

--------------------------------------------------
HumanEval/70

def strange_sort_list(lst):
    return sorted(lst, key=lambda x: (x % 2, x))

--------------------------------------------------
HumanEval/71

def triangle_area(a, b, c):
    if a + b > c and b + c > a and a + c > b:
        area = (a * b * c) / 2
        return round(area, 2)
    else:
        return -1

--------------------------------------------------
HumanEval/72

def will_it_fly(q, w):
    return all(q[i] == q[-i-1] for i in range(len(q))) and sum(q) <= w

--------------------------------------------------
HumanEval/73

def smallest_change(arr):
    mid = len(arr) // 2
    changes = 0
    for i in range(mid):
        if arr[i] != arr[len-i-1]:
            changes += 1
            arr[i] = arr[len-i-1]
    return changes

--------------------------------------------------
HumanEval/74

def total_match(list1, list2):
    total_chars1 = sum(len(s) for s in list1)
    total_chars2 = sum(len(s) for s in list2)
    return list1 if total_chars1 < total_chars2 else list2

--------------------------------------------------
HumanEval/75

def is_multiply_prime(a):
    if a < 1:
        return False
    for i in range(2, int(a**0.5) + 1):
        if a % i == 0 and is_prime(i) and is_prime(a//i):
            return True
    return False

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/76

def is_simple_power(x, n):
    return x == n ** (x // n)

--------------------------------------------------
HumanEval/77

def iscube(a):
    return a**(1/3) % 1 == 0

--------------------------------------------------
HumanEval/78

def hex_key(num):
    prime_digits = {2, 3, 5, 7, 11, 13, 17, 19}
    num = num.upper()
    count = 0
    for char in num:
        if char in 'ABCDEF' and int(char, 16) in prime_digits:
            count += 1
    return count

--------------------------------------------------
HumanEval/79

def minLengthAfterRemovals(nums):
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/80

def is_happy(s):
    return len(s) >= 3 and all(s[i] != s[i+1] != s[i+2] for i in range(len(s) - 2))

--------------------------------------------------
HumanEval/81

def numerical_letter_grade(grades):
    return ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'D+', 'D', 'D-', 'E'][min(12, max(0, (int(grade - 3) / 2)))] for grade in grades]

--------------------------------------------------
HumanEval/82

def prime_length(string):
    return len(string) in {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}

--------------------------------------------------
HumanEval/83

def starts_one_ends(n):
    return len([i for i in range(10**(n-1), 10**n) if str(i)[0] == '1' or str(i)[-1] == '1'])

--------------------------------------------------
HumanEval/84

def solve(N):
    return len(str(bin(N)[2:]))

--------------------------------------------------
HumanEval/85

def add(lst):
    return sum(x for i, x in enumerate(lst) if i % 2 and not x % 2)

--------------------------------------------------
HumanEval/86

def anti_shuffle(s):
    words = s.split()
    return " ".join(sorted(words, key=lambda x: "".join(sorted(x))))

--------------------------------------------------
HumanEval/87

def get_row(lst, x):
    return sorted([(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x], key=lambda x: (x[0], -x[1]))

--------------------------------------------------
HumanEval/88

def sort_array(arr):
    if sum(arr[0], arr[-1]) % 2 == 0:
        return sorted(arr, reverse=True)
    else:
        return sorted(arr)

--------------------------------------------------
HumanEval/89

def encrypt(s):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    new_alphabet = alphabet[2:] + alphabet[:2]
    table = str.maketrans(alphabet, new_alphabet)
    return s.translate(table)

--------------------------------------------------
HumanEval/90

def next_smallest(my_list):
    return min(my_list[1:], default=None)

--------------------------------------------------
HumanEval/91

def is_bored(string):
    return sum(1 for sentence in string.split('.')[:-1] if sentence.startswith('I'))

--------------------------------------------------
HumanEval/92

def any_int(x, y, z):
    return (x == y + z) or (y == x + z) or (z == x + y)

--------------------------------------------------
HumanEval/93

def encode(message):
    vowels = ['a', 'e', 'i', 'o', 'u']
    encoded = ''
    for char in message:
        if char.isalpha():
            encoded += chr(ord(char) + 1) if char.islower() else chr(ord(char) - 1)
        else:
            encoded += char
    
    for i, char in enumerate(encoded):
        if char in vowels:
            encoded = encoded[:i] + chr(ord(char) + 2) + encoded[i+1:]
    
    return encoded

--------------------------------------------------
HumanEval/94

def get_largest_prime_sum(my_list):
    largest_prime = max(my_list, key=is_prime)
    if largest_prime:
        return sum(int(digit) for digit in str(largest_prime))
    else:
        return 0

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/95

def check_dict_case(my_dict):
    if not my_dict:
        return False
    first_key = list(my_dict.keys())[0]
    return all(key.islower() or key.isupper() for key in my_dict.keys())

--------------------------------------------------
HumanEval/96

def count_up_to(n):
    prime_numbers = []
    for i in range(2, n+1):
        if all(i % j != 0 for j in range(2, int(i**0.5) + 1)):
            prime_numbers.append(i)
    return prime_numbers

--------------------------------------------------
HumanEval/97

def multiply(a, b):
    return a * b

--------------------------------------------------
HumanEval/98

def count_upper(s):
    return sum(c.isupper() for i, c in enumerate(s) if i % 2 == 0)

--------------------------------------------------
HumanEval/99

def closest_integer(value):
    return int(round(float(value)))

--------------------------------------------------
HumanEval/100

def make_a_pile(n):
    stones = [n]
    while n > 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = (n + 1) // 2
        stones.append(n)
    return stones[::-1]

--------------------------------------------------
HumanEval/101

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/102

def choose_num(x, y):
    # find the biggest even number in the range [x, y] inclusive
    for i in range(y, x-1, -1):
        if i % 2 == 0:
            return i
    return -1

--------------------------------------------------
HumanEval/103

def rounded_avg(n, m):
    if n > m:
        return -1
    sum = 0
    for i in range(n, m+1):
        sum += i
    average = int(sum / (m-n+1))
    binary_string = bin(average)[2:]
    return "0b" + binary_string

--------------------------------------------------
HumanEval/104

def unique_digits(x):
    return sorted(i for i in x if not any(int(digit) % 2 == 0 for digit in str(i)))

--------------------------------------------------
HumanEval/105

def by_length(arr):
    arr.sort()
    arr.reverse()
    return ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"][arr]

--------------------------------------------------
HumanEval/106

def f(n):
    result = []
    for i in range(1, n+1):
        if i % 2 == 0:
            factorial = 1
            for j in range(1, i+1):
                factorial *= j
            result.append(factorial)
        else:
            sum = 0
            for j in range(1, i+1):
                sum += j
            result.append(sum)
    return result

--------------------------------------------------
HumanEval/107

def even_odd_palindrome(n):
    even_count = 0
    odd_count = 0
    for i in range(1, n+1):
        if is_palindrome(i):
            if i % 2 == 0:
                even_count += 1
            else:
                odd_count += 1
    return (even_count, odd_count)

def is_palindrome(n):
    return str(n) == str(n)[::-1]

--------------------------------------------------
HumanEval/108

def count_nums(arr):
    return len([num for num in arr if sum(map(int, str(num))) > 0])

--------------------------------------------------
HumanEval/109

def move_one_ball(arr):
    if not arr:
        return True
    arr.sort()
    for i in range(len(arr) - 1):
        if arr[i] > arr[i + 1]:
            return False
    return True

--------------------------------------------------
HumanEval/110

def exchange(lst1, lst2):
    # Check if all elements in lst1 are even
    if all(x % 2 == 0 for x in lst1):
        return "YES"
    # Check if there are any even numbers in lst2
    elif any(x % 2 == 0 for x in lst2):
        return "NO"
    # Check if it is possible to exchange elements between lst1 and lst2 to make all elements of lst1 even
    else:
        # Sort both lists
        lst1.sort()
        lst2.sort()
        # Initialize variables to keep track of the current index in both lists
        i = 0
        j = 0
        # Loop through both lists and check if it is possible to exchange elements to make all elements of lst1 even
        while i < len(lst1) and j < len(lst2):
            if lst1[i] % 2 == 0 and lst2[j] % 2 != 0:
                # If the current element in lst1 is even and the current element in lst2 is odd, exchange elements
                lst1[i], lst2[j] = lst2[j], lst1[i]
                i += 1
                j += 1
            elif lst1[i] % 2 != 0 and lst2[j] % 2 == 0:
                # If the current element in lst1 is odd and the current element in lst2 is even, exchange elements
                lst1[i], lst2[j] = lst2[j], lst1[i]
                i += 1
                j += 1
            else:
                # If the current elements in both lists are not compatible for exchange, move on to the next element in lst1
                i += 1
        # After looping through both lists, check if all elements of lst1 are even
        if all(x % 2 == 0 for x in lst1):
            return "YES"
        else:
            return "NO"

--------------------------------------------------
HumanEval/111

def histogram(string):
    return {letter: string.count(letter) for letter in set(string)}

--------------------------------------------------
HumanEval/112

def reverse_delete(s, c):
    result = ""
    for char in s:
        if char not in c:
            result += char
    return (result, result == result[::-1])

--------------------------------------------------
HumanEval/113

def odd_count(my_list):
    return sum(int(x) % 2 == 1 for x in s) for s in my_list

--------------------------------------------------
HumanEval/114

def minSubArraySum(nums):
    min_sum = float('inf')
    for i in range(len(nums)):
        current_sum = 0
        for j in range(i, len(nums)):
            current_sum += nums[j]
            min_sum = min(min_sum, current_sum)
    return min_sum

--------------------------------------------------
HumanEval/115

def max_fill(grid, capacity):
    rows = len(grid)
    cols = len(grid[0])
    water = 0
    buckets = 0

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1:
                water += 1
                if water == capacity:
                    buckets += 1
                    water = 0

    if water > 0:
        buckets += 1

    return buckets

--------------------------------------------------
HumanEval/116

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/117

def select_words(s, n):
    return [word for word in s.split() if len(word) == n]

--------------------------------------------------
HumanEval/118

def get_closest_vowel(word):
    vowels = "aeiou"
    for i in range(len(word)-1, 0, -1):
        if word[i] in vowels:
            return word[i]
    return ""

--------------------------------------------------
HumanEval/119

def match_parens(lst):
    open_count = 0
    for char in lst:
        if char == '(':
            open_count += 1
        elif char == ')':
            open_count -= 1
        if open_count < 0:
            return 'No'
    return 'Yes' if open_count == 0 else 'No'

--------------------------------------------------
HumanEval/120

def maximum(arr, k):
    return sorted(arr, reverse=True)[:k]

--------------------------------------------------
HumanEval/121

def solution(lst):
    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)

--------------------------------------------------
HumanEval/122

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/123

def get_odd_collatz(n):
    if n <= 0:
        raise ValueError("n should be a positive integer.")
    
    collatz_list = [n]
    while n != 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
        collatz_list.append(n)
    
    return sorted([x for x in collatz_list if x % 2 != 0])

--------------------------------------------------
HumanEval/124

def valid_date(date):
    """
    Validates a given date string and returns True if the date is valid, otherwise False.

    The date is valid if all of the following rules are satisfied:
    1. The date string is not empty.
    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
    3. The months should not be less than 1 or higher than 12.
    4. The date should be in the format: mm-dd-yyyy
    """
    if not date:
        return False
    match = re.match(r'^(\d{2})-(\d{2})-(\d{4})$', date)
    if not match:
        return False
    month, day, year = map(int, match.groups())
    if month < 1 or month > 12:
        return False
    if day < 1 or day > 31:
        return False
    if month in [4, 6, 9, 11] and day == 31:
        return False
    if month == 2 and (day < 1 or day > 29):
        return False
    if year % 4 == 0 and month == 2 and day == 30:
        return False
    return True

--------------------------------------------------
HumanEval/125

def split_words(txt):
    if ' ' in txt:
        return txt.split()
    elif ',' in txt:
        return txt.split(',')
    else:
        result = 0
        for char in txt:
            if ord(char) % 2 == 1:
                result += 1
        return result

--------------------------------------------------
HumanEval/126

def is_sorted(my_list):
    return all(my_list[i] <= my_list[i + 1] for i in range(len(my_list) - 1))

--------------------------------------------------
HumanEval/127

def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return "NO"
    length = end - start + 1
    if length > 1 and all(length % i != 0 for i in range(2, int(length ** 0.5) + 1)):
        return "YES"
    return "NO"

--------------------------------------------------
HumanEval/128

def prod_signs(arr):
    if not arr:
        return None
    mult = 1
    for num in arr:
        if num < 0:
            mult *= -1
    return sum(abs(num) * mult for num in arr)

--------------------------------------------------
HumanEval/129

import heapq

def min_path(grid, k):
    # Initialize the heap with the first element of each row
    heap = [(grid[0][0], 0, 0)]
    # Initialize the visited matrix with False
    visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]
    # Initialize the result list
    result = []

    while len(heap) > 0:
        # Pop the smallest element from the heap
        value, row, col = heapq.heappop(heap)
        # If the current position is not visited and the path length is less than k
        if not visited[row][col] and len(result) < k:
            # Add the current value to the result list
            result.append(value)
            # Mark the current position as visited
            visited[row][col] = True
            # Loop through the neighbors of the current position
            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:
                # If the neighbor is within the grid and not visited
                if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and not visited[r][c]:
                    # Add the neighbor to the heap
                    heapq.heappush(heap, (grid[r][c], r, c))

    return result

def main():
    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    k = 3
    print(min_path(grid, k))

if __name__ == "__main__":
    main()

--------------------------------------------------
HumanEval/130

def tribonacci_sequence(n):
    if n == 1:
        return [1]
    elif n == 2:
        return [1, 3]
    else:
        seq = [1, 3]
        for i in range(2, n):
            seq.append(seq[i-1] + seq[i-2] + seq[i+1])
        return seq

--------------------------------------------------
HumanEval/131

def digits(n):
    return product(int(i) for i in str(n) if int(i) % 2 == 1)

--------------------------------------------------
HumanEval/132

def is_nested(s):
    stack = []
    for char in s:
        if char == '[':
            stack.append(char)
        elif char == ']':
            if not stack:
                return False
            stack.pop()
    return bool(stack)

--------------------------------------------------
HumanEval/133

def sum_squares(my_list):
    return sum(int(x)**2 for x in my_list)

--------------------------------------------------
HumanEval/134

def check_if_last_char_is_a_letter(txt):
    return txt and txt[-1].isalpha() and txt[-1] not in "abcdefghijklmnopqrstuvwxyz"

--------------------------------------------------
HumanEval/135

def can_arrange(arr):
    for i in range(len(arr) - 1, -1, -1):
        if arr[i] <= arr[i - 1]:
            return i
    return -1

--------------------------------------------------
HumanEval/136

def largest_smallest_integers(lst):
    return (max(filter(lambda x: x < 0, lst), default=None), min(filter(lambda x: x > 0, lst), default=None))

--------------------------------------------------
HumanEval/137

def compare_one(a, b):
    if isinstance(a, str):
        a = float(a.replace(",", "."))
    if isinstance(b, str):
        b = float(b.replace(",", "."))
    return a if a > b else b

--------------------------------------------------
HumanEval/138

def is_equal_to_sum_even(n):
    return n % 2 == 0 and any(n == i + j + k + l for i in range(2, int(n**0.5) + 1, 2) for j in range(2, int(n**0.5) + 1, 2) for k in range(2, int(n**0.5) + 1, 2) for l in range(2, int(n**0.5) + 1, 2))

--------------------------------------------------
HumanEval/139

def special_factorial(n):
    return n * special_factorial(n-1) if n > 1 else 1

--------------------------------------------------
HumanEval/140

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/141

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [-cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second)
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/142

def sum_squares(lst):
    result = 0
    for i, x in enumerate(lst):
        if i % 3 == 0:
            result += x * x
        elif i % 4 == 0:
            result += x * x * x
        else:
            result += x
    return result

--------------------------------------------------
HumanEval/143

def words_in_sentence(sentence):
    return " ".join([word for word in sentence.split() if is_prime(len(word))])

def is_prime(n):
    if n == 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/144

def simplify(x, n):
    x_num, x_denom = map(int, x.split("/"))
    n_num, n_denom = map(int, n.split("/"))
    return (x_num * n_num) % (x_denom * n_denom) == 0

--------------------------------------------------
HumanEval/145

def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(digit) for digit in str(abs(x))), x))

--------------------------------------------------
HumanEval/146

def special_filter(nums):
    return sum(num > 10 and num % 10 in [1, 3, 5, 7, 9] and num // 100 in [1, 3, 5, 7, 9] for num in nums)

--------------------------------------------------
HumanEval/147

def get_max_triples(n):
    a = [i * i - i + 1 for i in range(1, n + 1)]
    count = 0
    for i in range(len(a)):
        for j in range(i + 1, len(a)):
            for k in range(j + 1, len(a)):
                if a[i] + a[j] + a[k] % 3 == 0:
                    count += 1
    return count

--------------------------------------------------
HumanEval/148

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/149

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/150

def x_or_y(n, x, y):
    return x if is_prime(n) else y

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/151

def double_the_difference(lst):
    return sum(x**2 for x in lst if x % 2 != 0 and x > 0 and x == int(x))

--------------------------------------------------
HumanEval/152

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/153

def strongest_extension(class_name, extensions):
    return max(extensions, key=lambda ext: sum(1 for c in ext if c.isupper()) - sum(1 for c in ext if c.islower()))

--------------------------------------------------
HumanEval/154

def cycpattern_check(word1, word2):
    return any(word2 in word1[i:] for i in range(len(word1)))

--------------------------------------------------
HumanEval/155

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [ -cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second) 
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/156

def int_to_mini_roman(number):
    """
    Given a positive integer, obtain its roman numeral equivalent as a string,
    and return it in lowercase.
    Restrictions: 1 <= num <= 1000

    Examples:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """
    num = str(number)
    roman = ''
    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']
    for i in range(len(values)):
        while num[0] == '1':
            roman += numerals[i]
            num = num[1:]
        if num[0] == '0':
            num = num[1:]
    return roman

--------------------------------------------------
HumanEval/157

def right_angle_triangle(a, b, c):
    return any([(a**2 + b**2 == c**2), (b**2 + c**2 == a**2), (c**2 + a**2 == b**2)])

--------------------------------------------------
HumanEval/158

def find_max(words):
    if not words:
        return None
    return max(words, key=lambda x: (len(set(x)), x))

--------------------------------------------------
HumanEval/159

def eat(number, need, remaining):
    return [min(remaining, number + need), max(0, remaining - (number + need))]

--------------------------------------------------
HumanEval/160

def do_algebra(operator, operand):
    result = operand[0]
    for i in range(len(operator)):
        op = operator[i]
        if op == '+':
            result += operand[i+1]
        elif op == '-':
            result -= operand[i+1]
        elif op == '*':
            result *= operand[i+1]
        elif op == '//':
            result //= operand[i+1]
        elif op == '**':
            result **= operand[i+1]
        else:
            raise ValueError("Invalid operator")
    return result

--------------------------------------------------
HumanEval/161

def solve(s):
    return "".join([c.upper() if c.islower() else c.lower() for c in s]) or s[::-1]

--------------------------------------------------
HumanEval/162

def minLengthAfterRemovals(nums: List[int]) -> int:
    counter = Counter(nums)
    heap = [-cnt for cnt in counter.values()]
    heapify(heap)
    while len(heap) > 1:
        largest = -heappop(heap)
        second = -heappop(heap)
        if largest > 1:
            heappush(heap, 1-largest)
        if second > 1:
            heappush(heap, 1-second)
    return -heap[0] if heap else 0

--------------------------------------------------
HumanEval/163

def generate_integers(a, b):
    if a > b:
        a, b = b, a
    return [i for i in range(a, b+1) if i % 2 == 0]

--------------------------------------------------
