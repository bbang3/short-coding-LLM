HumanEval/0

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    return any(abs(a - b) <= threshold for a, b in zip(numbers, numbers[1:]))

--------------------------------------------------
HumanEval/1

def separate_paren_groups(paren_string):
    return re.findall(r'\(.*?\)', paren_string)

--------------------------------------------------
HumanEval/2

def truncate_number(number: float) -> float:
    return number % 1

--------------------------------------------------
HumanEval/3

def below_zero(operations: List[int]) -> bool:
    return any(operation < 0 for operation in operations)

--------------------------------------------------
HumanEval/4

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/5

def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    return [x for pair in zip(numbers[::2], numbers[1::2]) for x in pair] + numbers[-1:]

--------------------------------------------------
HumanEval/6

def parse_nested_parens(paren_string: str) -> List[int]:
    def get_max_level(s: str) -> int:
        level = 0
        max_level = 0
        for c in s:
            if c == '(':
                level += 1
                max_level = max(max_level, level)
            elif c == ')':
                level -= 1
        return max_level
    return [get_max_level(s) for s in paren_string.split()]

--------------------------------------------------
HumanEval/7

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/8

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/9

def rolling_max(numbers: List[int]) -> List[int]:
    return list(accumulate(numbers, max))

--------------------------------------------------
HumanEval/10

def make_palindrome(string: str) -> str:
    """Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    """
    if not string or len(string) == 1:
        return string

    # find the longest postfix of supplied string that is a palindrome
    postfix_start = 0
    for i in range(len(string) - 1, 0, -1):
        if string[i:] == string[i::-1]:
            postfix_start = i
            break

    # append to the end of the string reverse of a string prefix that comes before the palindromic suffix
    return string + string[postfix_start:len(string) - 1][::-1]

--------------------------------------------------
HumanEval/11

def string_xor(a: str, b: str) -> str:
    return "".join(str(int(x) ^ int(y)) for x, y in zip(a, b))

--------------------------------------------------
HumanEval/12

def longest(strings: List[str]) -> Optional[str]:
    return max(strings, key=len) if strings else None

--------------------------------------------------
HumanEval/13

def greatest_common_divisor(a, b):
    return a if not b else greatest_common_divisor(b, a % b)

--------------------------------------------------
HumanEval/14

def all_prefixes(string: str) -> List[str]:
    return list(string[:i+1] for i in range(len(string)))

--------------------------------------------------
HumanEval/15

def string_sequence(n: int) -> str:
    return " ".join(map(str, range(1, n+1)))

--------------------------------------------------
HumanEval/16

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/17

def parse_music(music_string: str) -> List[int]:
    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[note] for note in music_string.split()]

--------------------------------------------------
HumanEval/18

def how_many_times(string, substring):
    return sum(1 for i in range(len(string) - len(substring) + 1) if string[i:i+len(substring)] == substring)

--------------------------------------------------
HumanEval/19

def sort_numbers(numbers: str) -> str:
    number_list = numbers.split()
    sorted_numbers = sorted(number_list, key=lambda x: int(x))
    return " ".join(sorted_numbers)

--------------------------------------------------
HumanEval/20

def find_closest_elements(numbers):
    numbers.sort()
    closest_pair = (numbers[0], numbers[1])
    smallest_diff = abs(closest_pair[0] - closest_pair[1])

    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            pair = (numbers[i], numbers[j])
            diff = abs(pair[0] - pair[1])
            if diff < smallest_diff:
                smallest_diff = diff
                closest_pair = pair

    return closest_pair

--------------------------------------------------
HumanEval/21

def rescale_to_unit(numbers):
    """
    Given a list of numbers, apply a linear transform to the list
    such that the smallest number will become 0 and the largest will become 1.
    """
    return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]

--------------------------------------------------
HumanEval/22

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/23

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/24

def largest_divisor(n):
    return next(i for i in range(n, 0, -1) if n % i == 0)

--------------------------------------------------
HumanEval/25

def factorize(n: int) -> List[int]:
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:
        factors.append(n)
    return factors

--------------------------------------------------
HumanEval/26

def remove_duplicates(numbers: List[int]) -> List[int]:
    return list(dict.fromkeys(numbers))

--------------------------------------------------
HumanEval/27

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/28

def concatenate(strings: List[str]) -> str:
    return "".join(strings)

--------------------------------------------------
HumanEval/29

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/30

def get_positive(my_list):
    return list(filter(lambda x: x > 0, my_list))

--------------------------------------------------
HumanEval/31

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/32

def find_zero(xs: list):
    """
    Finds a zero of the polynomial defined by the given coefficients xs.
    The function returns only one zero, even if multiple zeros exist.
    The function only takes lists xs with an even number of coefficients and the largest non-zero coefficient, which guarantees a solution.
    """
    # Implement the find_zero function here
    return 0

--------------------------------------------------
HumanEval/33

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/34

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/35

def max_element(my_list):
    return max(my_list)

--------------------------------------------------
HumanEval/36

def fizz_buzz(n: int) -> int:
    count = 0
    for i in range(1, n):
        if i % 11 == 0 or i % 13 == 0:
            if '7' in str(i):
                count += 1
    return count

--------------------------------------------------
HumanEval/37

def sort_even(l):
    return [x for i, x in enumerate(l) if i % 2 == 0 or x not in l[1::2]]

--------------------------------------------------
HumanEval/38

def decode_cyclic(s):
    # split string into groups of length 3
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group unless it has fewer than 3 elements
    groups = [(group[-1:] + group[:-1]) if len(group) == 3 else group for group in groups]
    return "".join(groups)

--------------------------------------------------
HumanEval/39

def prime_fib(n: int) -> int:
    fib_seq = [1, 2]
    for i in range(2, n):
        fib_seq.append(fib_seq[-1] + fib_seq[-2])
    return next(x for x in fib_seq if is_prime(x))

--------------------------------------------------
HumanEval/40

def triples_sum_to_zero(my_list):
    for i, x in enumerate(my_list):
        for j, y in enumerate(my_list[i+1:]):
            if -x-y in my_list[j+1:]:
                return True
    return False

--------------------------------------------------
HumanEval/41

def car_race_collision(n: int) -> int:
    """
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """
    # Calculate the number of collisions
    return n * (n - 1) // 2

--------------------------------------------------
HumanEval/42

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/43

def pairs_sum_to_zero(my_list):
    return any(my_list[i] + my_list[j] == 0 for i in range(len(my_list)) for j in range(i+1, len(my_list)))

--------------------------------------------------
HumanEval/44

def change_base(x: int, base: int) -> str:
    """Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.
    """
    return f"{x:(base)}"

--------------------------------------------------
HumanEval/45

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/46

def fib4(n):
    if n <= 3:
        return 0
    elif n == 4:
        return 2
    a, b, c, d = 0, 0, 2, 0
    for i in range(5, n+1):
        a, b, c, d = b, c, d, a + b + c + d
    return d

--------------------------------------------------
HumanEval/47

def median(l):
    """Return median of elements in the list l.
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """
    return sorted(l)[len(l) // 2] if len(l) % 2 else (sorted(l)[len(l) // 2 - 1] + sorted(l)[len(l) // 2]) / 2

--------------------------------------------------
HumanEval/48

def is_palindrome(text: str) -> bool:
    return text == text[::-1]

--------------------------------------------------
HumanEval/49

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/50

def decode_shift(s):
    return "".join([chr(((ord(ch) - 5 - ord("a")) % 26) + ord("a")) for ch in s])

--------------------------------------------------
HumanEval/51

def remove_vowels(text):
    return ''.join([char for char in text if char.lower() not in "aeiou"])

--------------------------------------------------
HumanEval/52

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/53

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/54

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/55

def fib(n: int) -> int:
    """Return n-th Fibonacci number."""
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)

--------------------------------------------------
HumanEval/56

def correct_bracketing(brackets: str) -> bool:
    """
    Returns True if every opening bracket has a corresponding closing bracket.
    """
    stack = []
    for char in brackets:
        if char == "<":
            stack.append(char)
        elif char == ">":
            if len(stack) == 0:
                return False
            stack.pop()
    return len(stack) == 0

--------------------------------------------------
HumanEval/57

def monotonic(l):
    return all(l[i] >= l[i-1] for i in range(1, len(l))) or all(l[i] <= l[i-1] for i in range(1, len(l)))

--------------------------------------------------
HumanEval/58

def common(l1, l2):
    return list(set(l1) & set(l2))

--------------------------------------------------
HumanEval/59

def largest_prime_factor(n):
    if n <= 1:
        return n
    for i in range(int(n**0.5), 1, -1):
        if n % i == 0 and is_prime(i):
            return i
    return 1

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/60

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/61

def correct_bracketing(brackets: str) -> bool:
    """
    Returns True if every opening bracket has a corresponding closing bracket.
    """
    stack = []
    for char in brackets:
        if char == "(":
            stack.append(char)
        elif char == ")":
            if not stack:
                return False
            stack.pop()
    return not stack

--------------------------------------------------
HumanEval/62

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/63

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/64

def vowels_count(word):
    return sum(map(str.lower, word).count(v) for v in 'aeiou')

--------------------------------------------------
HumanEval/65

def circular_shift(x, shift):
    """Circular shift the digits of the integer x, shift the digits right by shift
    and return the result as a string.
    If shift > number of digits, return digits reversed.
    >>> circular_shift(12, 1)
    "21"
    >>> circular_shift(12, 2)
    "12"
    """
    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[-shift:] + s[:-shift]

--------------------------------------------------
HumanEval/66

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/67

def fruit_distribution(s, n):
    apple, orange = map(int, s.split())
    return n - (apple + orange)

--------------------------------------------------
HumanEval/68

def pluck(arr):
    if not arr:
        return []
    even_values = [x for x in arr if x % 2 == 0]
    if not even_values:
        return []
    smallest_even_value = min(even_values)
    smallest_even_index = arr.index(smallest_even_value)
    return [smallest_even_value, smallest_even_index]

--------------------------------------------------
HumanEval/69

def search(lst):
    # create a dictionary to store the count of each integer
    freq = {}
    for num in lst:
        if num in freq:
            freq[num] += 1
        else:
            freq[num] = 1

    # find the maximum integer that satisfies the condition
    max_int = -1
    for num, count in freq.items():
        if num > 0 and count >= num and num > max_int:
            max_int = num

    return max_int

--------------------------------------------------
HumanEval/70

def strange_sort_list(lst):
    return sorted(lst, key=lambda x: (x % 2, x))

--------------------------------------------------
HumanEval/71

def triangle_area(a, b, c):
    if a + b > c and b + c > a and a + c > b:
        area = (a * b * c) / 2
        return round(area, 2)
    else:
        return -1

--------------------------------------------------
HumanEval/72

def will_it_fly(q, w):
    return q == q[::-1] and sum(q) % 2 == w % 2

--------------------------------------------------
HumanEval/73

def smallest_change(arr):
    mid = len(arr) // 2
    changes = 0
    for i in range(mid):
        if arr[i] != arr[len-i-1]:
            changes += 1
            arr[i] = arr[len-i-1]
    return changes

--------------------------------------------------
HumanEval/74

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/75

def is_multiply_prime(a):
    if a < 1:
        return False
    for i in range(2, int(a**0.5) + 1):
        if a % i == 0 and is_prime(i) and is_prime(a//i):
            return True
    return False

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/76

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/77

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/78

def hex_key(num):
    return sum(int(char, 16) in set([2, 3, 5, 7, 11, 13, 17, 19]) for char in num.upper())

--------------------------------------------------
HumanEval/79

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/80

def is_happy(s):
    return len(s) >= 3 and all(s[i] != s[i+1] for i in range(len(s) - 2))

--------------------------------------------------
HumanEval/81

def numerical_letter_grade(grades):
    return ['E', 'D-', 'D', 'D+', 'C-', 'C', 'C+', 'B-', 'B', 'B+', 'A-', 'A', 'A+'][min(12, max(0, (int(grade - 3) / 2)))] for grade in grades]

--------------------------------------------------
HumanEval/82

def prime_length(string):
    return len(string) in {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}

--------------------------------------------------
HumanEval/83

def starts_one_ends(n):
    return len(str(10**(n-1))) + len(str(10**n-1))

--------------------------------------------------
HumanEval/84

def solve(N):
    return bin(sum(map(int, str(N))))[2:]

--------------------------------------------------
HumanEval/85

def add(lst):
    return sum(x for i, x in enumerate(lst) if i % 2 and not x % 2)

--------------------------------------------------
HumanEval/86

def anti_shuffle(s):
    return " ".join(sorted(s.split()))

--------------------------------------------------
HumanEval/87

def get_row(lst, x):
    return sorted([(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x], key=lambda x: (x[0], -x[1]))

--------------------------------------------------
HumanEval/88

def sort_array(arr):
    return sorted(arr, key=lambda x: (x[0]+x[-1])%2)

--------------------------------------------------
HumanEval/89

def encrypt(s):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    new_alphabet = alphabet[2:] + alphabet[:2]
    table = str.maketrans(alphabet, new_alphabet)
    return s.translate(table)

--------------------------------------------------
HumanEval/90

def next_smallest(my_list):
    return min(filter(lambda x: x != my_list[0], my_list), default=None)

--------------------------------------------------
HumanEval/91

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/92

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/93

def encode(message):
    vowels = ['a', 'e', 'i', 'o', 'u']
    encoded = ''
    for char in message:
        if char.isalpha():
            encoded += chr(ord(char) + 1) if char.islower() else chr(ord(char) - 1)
        else:
            encoded += char
    
    for i, char in enumerate(encoded):
        if char in vowels:
            encoded = encoded[:i] + chr(ord(char) + 2) + encoded[i+1:]
    
    return encoded

--------------------------------------------------
HumanEval/94

def get_largest_prime_sum(my_list):
    largest_prime = max(my_list, key=lambda x: x if is_prime(x) else 0)
    return sum(int(digit) for digit in str(largest_prime)) if largest_prime else 0

--------------------------------------------------
HumanEval/95

def check_dict_case(my_dict):
    if not my_dict:
        return False
    first_key = list(my_dict.keys())[0]
    return all(key.islower() or key.isupper() for key in my_dict.keys())

--------------------------------------------------
HumanEval/96

def count_up_to(n):
    return [x for x in range(2, n+1) if all(x % i != 0 for i in range(2, int(x**0.5) + 1))]

--------------------------------------------------
HumanEval/97

def multiply(a, b):
    return a * b

--------------------------------------------------
HumanEval/98

def count_upper(s):
    return sum(c.isupper() for i, c in enumerate(s) if i % 2 == 0)

--------------------------------------------------
HumanEval/99

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/100

def make_a_pile(n):
    return list(range(n, 0, -1)) if n > 0 else []

--------------------------------------------------
HumanEval/101

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/102

def choose_num(x, y):
    # find the biggest even number in the range [x, y] inclusive
    for i in range(y, x-1, -1):
        if i % 2 == 0:
            return i
    return -1

--------------------------------------------------
HumanEval/103

def rounded_avg(n, m):
    if n > m:
        return -1
    return f"0b{bin((sum(range(n, m+1)) // (m-n+1))}[2:])"

--------------------------------------------------
HumanEval/104

def unique_digits(x):
    return sorted([i for i in x if not any(int(digit) % 2 == 0 for digit in str(i))])

--------------------------------------------------
HumanEval/105

def by_length(arr):
    arr.sort(reverse=True)
    return ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"][len(arr)]

--------------------------------------------------
HumanEval/106

def f(n):
    return [i * (i - 1) // 2 if i % 2 else sum(range(1, i + 1)) for i in range(1, n + 1)]

--------------------------------------------------
HumanEval/107

def even_odd_palindrome(n):
    even_count = sum(1 for i in range(1, n+1) if is_palindrome(i) and i % 2 == 0)
    odd_count = sum(1 for i in range(1, n+1) if is_palindrome(i) and i % 2 != 0)
    return (even_count, odd_count)

--------------------------------------------------
HumanEval/108

def count_nums(arr):
    return len([num for num in arr if sum(map(int, str(num))) > 0])

--------------------------------------------------
HumanEval/109

def move_one_ball(arr):
    return all(arr[i] == arr[i+1] for i in range(len(arr)-1))

--------------------------------------------------
HumanEval/110

def exchange(lst1, lst2):
    # Check if all elements in lst1 are even
    if all(x % 2 == 0 for x in lst1):
        return "YES"
    # Check if there are any even numbers in lst2
    elif any(x % 2 == 0 for x in lst2):
        return "NO"
    # Check if it is possible to exchange elements between lst1 and lst2 to make all elements of lst1 even
    else:
        # Sort both lists
        lst1.sort()
        lst2.sort()
        # Initialize variables to keep track of the current index in both lists
        i = 0
        j = 0
        # Loop through both lists and check if it is possible to exchange elements to make all elements of lst1 even
        while i < len(lst1) and j < len(lst2):
            if lst1[i] % 2 == 0 and lst2[j] % 2 != 0:
                # If the current element in lst1 is even and the current element in lst2 is odd, exchange elements
                lst1[i], lst2[j] = lst2[j], lst1[i]
                i += 1
                j += 1
            elif lst1[i] % 2 != 0 and lst2[j] % 2 == 0:
                # If the current element in lst1 is odd and the current element in lst2 is even, exchange elements
                lst1[i], lst2[j] = lst2[j], lst1[i]
                i += 1
                j += 1
            else:
                # If the current elements in both lists are not compatible for exchange, move on to the next element in lst1
                i += 1
        # After looping through both lists, check if all elements of lst1 are even
        if all(x % 2 == 0 for x in lst1):
            return "YES"
        else:
            return "NO"

--------------------------------------------------
HumanEval/111

def histogram(string):
    return {letter: string.count(letter) for letter in set(string)}

--------------------------------------------------
HumanEval/112

def reverse_delete(s, c):
    return ("".join(filter(lambda x: x not in c, s)), "".join(filter(lambda x: x not in c, s)) == "".join(filter(lambda x: x not in c, s))[::-1])

--------------------------------------------------
HumanEval/113

def odd_count(my_list):
    return ["the number of odd elements {} in the string {} of the input.".format(str(len([x for x in s if int(x) % 2 == 1])), i) for i, s in enumerate(my_list)]

--------------------------------------------------
HumanEval/114

def minSubArraySum(nums):
    return min(sum(nums[i:j+1]) for i in range(len(nums)) for j in range(i, len(nums)))

--------------------------------------------------
HumanEval/115

def max_fill(grid, capacity):
    rows = len(grid)
    cols = len(grid[0])
    water = 0
    buckets = 0

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1:
                water += 1
                if water == capacity:
                    buckets += 1
                    water = 0

    if water > 0:
        buckets += 1

    return buckets

--------------------------------------------------
HumanEval/116

def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))

--------------------------------------------------
HumanEval/117

def select_words(s, n):
    return [word for word in s.split() if len(word) == n]

--------------------------------------------------
HumanEval/118

def get_closest_vowel(word):
    vowels = "aeiou"
    for i in range(len(word)-1, 0, -1):
        if word[i] in vowels:
            return word[i]
    return ""

--------------------------------------------------
HumanEval/119

def match_parens(lst):
    return 'Yes' if len(lst) % 2 == 0 and all(c != ')' for c in lst) else 'No'

--------------------------------------------------
HumanEval/120

def maximum(arr, k):
    return sorted(arr, reverse=True)[:k]

--------------------------------------------------
HumanEval/121

def solution(lst):
    return sum(x for i, x in enumerate(lst) if not i % 2 and x % 2)

--------------------------------------------------
HumanEval/122

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/123

def get_odd_collatz(n):
    if n <= 0:
        raise ValueError("n should be a positive integer.")
    return sorted([x for x in [n, *[3*x+1 if x%2 else x//2 for x in range(1, n)]] if x % 2 != 0])

--------------------------------------------------
HumanEval/124

def valid_date(date):
    if not date:
        return False
    match = re.match(r'^(\d{2})-(\d{2})-(\d{4})$', date)
    if not match:
        return False
    month, day, year = map(int, match.groups())
    if month < 1 or month > 12:
        return False
    if day < 1 or day > 31:
        return False
    if month in [4, 6, 9, 11] and day == 31:
        return False
    if month == 2 and (day < 1 or day > 29):
        return False
    if year % 4 == 0 and month == 2 and day == 30:
        return False
    return True

--------------------------------------------------
HumanEval/125

def split_words(txt):
    if ' ' in txt or ',' in txt:
        return txt.split()
    else:
        result = 0
        for char in txt:
            if ord(char) % 2 == 1:
                result += 1
        return result

--------------------------------------------------
HumanEval/126

def is_sorted(my_list):
    return all(my_list[i] <= my_list[i + 1] for i in range(len(my_list) - 1))

--------------------------------------------------
HumanEval/127

def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return "NO"
    length = end - start + 1
    if length > 1 and all(length % i != 0 for i in range(2, int(length ** 0.5) + 1)):
        return "YES"
    return "NO"

--------------------------------------------------
HumanEval/128

def prod_signs(arr):
    if not arr:
        return None
    return sum(num * (1 if num > 0 else -1) for num in arr)

--------------------------------------------------
HumanEval/129

def min_path(grid, k):
    # Initialize the heap with the first element of each row
    heap = [(grid[0][0], 0, 0)]
    # Initialize the visited matrix with False
    visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]
    # Initialize the result list
    result = []

    while len(heap) > 0:
        # Pop the smallest element from the heap
        value, row, col = heapq.heappop(heap)
        # If the current position is not visited and the path length is less than k
        if not visited[row][col] and len(result) < k:
            # Add the current value to the result list
            result.append(value)
            # Mark the current position as visited
            visited[row][col] = True
            # Loop through the neighbors of the current position
            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:
                # If the neighbor is within the grid and not visited
                if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and not visited[r][c]:
                    # Add the neighbor to the heap
                    heapq.heappush(heap, (grid[r][c], r, c))

    return result

--------------------------------------------------
HumanEval/130

def tribonacci_sequence(n):
    if n == 1:
        return [1]
    elif n == 2:
        return [1, 3]
    else:
        seq = [1, 3]
        for i in range(2, n):
            seq.append(seq[i-1] + seq[i-2] + seq[i+1])
        return seq

--------------------------------------------------
HumanEval/131

def digits(n):
    return product(int(digit) for digit in str(n) if int(digit) % 2 == 1)

--------------------------------------------------
HumanEval/132

def is_nested(string):
    stack = []
    for char in string:
        if char == '[':
            stack.append(char)
        elif char == ']':
            if len(stack) == 0:
                return False
            stack.pop()
    return len(stack) != 0

--------------------------------------------------
HumanEval/133

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/134

def check_if_last_char_is_a_letter(txt):
    return txt.endswith(tuple("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) if txt else False

--------------------------------------------------
HumanEval/135

def can_arrange(arr):
    for i in range(len(arr) - 1, -1, -1):
        if arr[i] <= arr[i - 1]:
            return i
    return -1

--------------------------------------------------
HumanEval/136

def largest_smallest_integers(lst):
    return max(filter(lambda x: x < 0, lst)), min(filter(lambda x: x > 0, lst))

--------------------------------------------------
HumanEval/137

def compare_one(a, b):
    try:
        a = float(a.replace(",", "."))
    except ValueError:
        pass
    try:
        b = float(b.replace(",", "."))
    except ValueError:
        pass
    if a == b:
        return None
    return a if a > b else b

--------------------------------------------------
HumanEval/138

def is_equal_to_sum_even(n):
    return n % 2 == 0 and any(n == i + j + k + l for i in range(2, int(n**0.5) + 1, 2) for j in range(2, int(n**0.5) + 1, 2) for k in range(2, int(n**0.5) + 1, 2) for l in range(2, int(n**0.5) + 1, 2))

--------------------------------------------------
HumanEval/139

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/140

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/141

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/142

def sum_squares(lst):
    return sum(x**(i%3+1) for i, x in enumerate(lst))

--------------------------------------------------
HumanEval/143

def words_in_sentence(sentence):
    return " ".join([word for word in sentence.split() if is_prime(len(word))])

def is_prime(n):
    if n == 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/144

def simplify(x, n):
    x_num, x_denom = map(int, x.split("/"))
    n_num, n_denom = map(int, n.split("/"))
    return (x_num * n_num) % (x_denom * n_denom) == 0

--------------------------------------------------
HumanEval/145

def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), x))

--------------------------------------------------
HumanEval/146

def special_filter(nums):
    return sum(1 for num in nums if num > 10 and num % 10 in [1, 3, 5, 7, 9] and num // 100 in [1, 3, 5, 7, 9])

--------------------------------------------------
HumanEval/147

def get_max_triples(n):
    a = [i * i - i + 1 for i in range(1, n + 1)]
    return sum(a[i] + a[j] + a[k] % 3 == 0 for i in range(len(a)) for j in range(i + 1, len(a)) for k in range(j + 1, len(a)))

--------------------------------------------------
HumanEval/148

def between_planets(planet1, planet2):
    planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
    index1 = planets.index(planet1)
    index2 = planets.index(planet2)
    return tuple(planets[index1+1:index2])

--------------------------------------------------
HumanEval/149

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/150

def x_or_y(n, x, y):
    return x if is_prime(n) else y

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/151

def double_the_difference(lst):
    return sum(x**2 for x in lst if x % 2 != 0 and x > 0 and x == int(x))

--------------------------------------------------
HumanEval/152

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/153

def strongest_extension(class_name, extensions):
    return max(extensions, key=lambda x: sum(1 for c in x if c.isupper()) - sum(1 for c in x if c.islower()))

--------------------------------------------------
HumanEval/154

def cycpattern_check(word1, word2):
    return any(word2 in word1[i:] for i in range(len(word1)))

--------------------------------------------------
HumanEval/155

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/156

def int_to_mini_roman(number):
    """
    Given a positive integer, obtain its roman numeral equivalent as a string,
    and return it in lowercase.
    Restrictions: 1 <= num <= 1000

    Examples:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """
    num = str(number)
    roman = ''
    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']
    for i in range(len(values)):
        while num[0] == '1':
            roman += numerals[i]
            num = num[1:]
        if num[0] == '0':
            num = num[1:]
    return roman

--------------------------------------------------
HumanEval/157

def right_angle_triangle(a, b, c):
    return (a**2 + b**2 == c**2) or (b**2 + c**2 == a**2) or (c**2 + a**2 == b**2)

--------------------------------------------------
HumanEval/158

def find_max(words):
    if not words:
        return None
    return max(words, key=lambda x: (len(set(x)), x))

--------------------------------------------------
HumanEval/159

def eat(number, need, remaining):
    return [min(remaining, number + need), max(0, remaining - (number + need))]

--------------------------------------------------
HumanEval/160

def do_algebra(operator, operand):
    result = operand[0]
    for op, num in zip(operator, operand[1:]):
        if op == '+':
            result += num
        elif op == '-':
            result -= num
        elif op == '*':
            result *= num
        elif op == '//':
            result //= num
        elif op == '**':
            result **= num
        else:
            raise ValueError("Invalid operator")
    return result

--------------------------------------------------
HumanEval/161

def solve(s):
    return "".join([c.upper() if c.isalpha() and c.islower() else c.lower() if c.isalpha() and c.isupper() else c for c in s])

--------------------------------------------------
HumanEval/162

def minLengthAfterRemovals(self, nums: List[int]) -> int:
    scount = Counter(nums)
    arr = sorted([scount[num] for num in sorted(scount.keys())], key=lambda x: -x)    
    
    return (arr[0] - sum(arr[1:])) if arr[0] > sum(arr[1:]) else sum(arr) % 2

--------------------------------------------------
HumanEval/163

def generate_integers(a, b):
    return list(range(a, b+1, 2))

--------------------------------------------------
