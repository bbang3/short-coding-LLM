HumanEval/0

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if abs(numbers[i] - numbers[j]) <= threshold:
                return True
    return False

--------------------------------------------------
HumanEval/1

def separate_paren_groups(paren_string: str) -> List[str]:
    """
    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    """
    result = []
    stack = []
    current_string = ""
    for char in paren_string:
        if char == "(":
            stack.append(char)
        elif char == ")":
            stack.pop()
        if not stack:
            result.append(current_string)
            current_string = ""
        else:
            current_string += char
    return result

--------------------------------------------------
HumanEval/2

def truncate_number(number: float) -> float:
    """ Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    >>> truncate_number(3.5)
    0.5
    """
    return abs(number - int(number))

--------------------------------------------------
HumanEval/3

def below_zero(operations: List[int]) -> bool:
    balance = 0
    for operation in operations:
        balance += operation
        if balance < 0:
            return True
    return False

--------------------------------------------------
HumanEval/4

def mean_absolute_deviation(numbers: List[float]) -> float:
    mean = sum(numbers) / len(numbers)
    return sum([abs(x - mean) for x in numbers]) / len(numbers)

--------------------------------------------------
HumanEval/5

def intersperse(numbers, delimeter):
    result = []
    for num in numbers:
        result.append(num)
        result.append(delimeter)
    return result[:-1]  # remove last delimeter

--------------------------------------------------
HumanEval/6

def parse_nested_parens(paren_string: str) -> List[int]:
    """
    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """
    # Step 1: Split the input string into groups based on spaces
    groups = paren_string.split(" ")

    # Step 2: Initialize a list to store the maximum nesting level for each group
    max_nesting_levels = []

    # Step 3: Iterate over each group and calculate its maximum nesting level
    for group in groups:
        # Step 3a: Initialize a variable to keep track of the current nesting level
        current_level = 0

        # Step 3b: Iterate over each character in the group and update the nesting level accordingly
        for char in group:
            if char == "(":
                current_level += 1
            elif char == ")":

--------------------------------------------------
HumanEval/7

def filter_by_substring(strings, substring):
    filtered_strings = []
    for string in strings:
        if substring in string:
            filtered_strings.append(string)
    return filtered_strings

--------------------------------------------------
HumanEval/8

def sum_product(numbers):
    sum = 0
    product = 1
    for num in numbers:
        sum += num
        product *= num
    return (sum, product)

--------------------------------------------------
HumanEval/9

def rolling_max(numbers: List[int]) -> List[int]:
    result = []
    max_num = -float('inf')
    for num in numbers:
        if num > max_num:
            max_num = num
        result.append(max_num)
    return result

--------------------------------------------------
HumanEval/10

def make_palindrome(string):
    # Find the longest postfix that is a palindrome
    for i in range(len(string), 0, -1):
        if string[i:] == string[i:][::-1]:
            break
    else:
        return string

    # Append the reverse of the prefix to the end of the string
    return string + string[:i][::-1]

--------------------------------------------------
HumanEval/11

def string_xor(a, b):
    return bin(int(a, 2) ^ int(b, 2))[2:]

--------------------------------------------------
HumanEval/12

def longest(strings):
    if not strings:
        return None
    longest_string = ""
    for string in strings:
        if len(string) > len(longest_string):
            longest_string = string
    return longest_string

--------------------------------------------------
HumanEval/13

def greatest_common_divisor(a, b):
    gcd = 0
    for i in range(1, min(a, b) + 1):
        if a % i == 0 and b % i == 0:
            gcd = i
    return gcd

--------------------------------------------------
HumanEval/14

def all_prefixes(string):
    prefixes = []
    for i in range(len(string)):
        prefixes.append(string[:i+1])
    return prefixes

--------------------------------------------------
HumanEval/15

def string_sequence(n):
    """Return a string containing space-delimited numbers starting from 0 upto n inclusive."""
    output = ""
    for i in range(n+1):
        output += str(i) + " "
    return output.strip()

--------------------------------------------------
HumanEval/16

def count_distinct_characters(string: str) -> int:
    """ Given a string, find out how many distinct characters (regardless of case) does it consist of
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """
    return len(set(string.lower()))

--------------------------------------------------
HumanEval/17

def parse_music(music_string: str) -> List[int]:
    note_map = {'o': 4, '|': 2, '.|': 1}
    notes = music_string.split()
    return [note_map[note] for note in notes]

--------------------------------------------------
HumanEval/18

def how_many_times(string: str, substring: str) -> int:
    count = 0
    for i in range(len(string)):
        if string[i] == substring[0]:
            if string[i:].startswith(substring):
                count += 1
    return count

--------------------------------------------------
HumanEval/19

def sort_numbers(numbers: str) -> str:
    number_map = {
        "zero": 0,
        "one": 1,
        "two": 2,
        "three": 3,
        "four": 4,
        "five": 5,
        "six": 6,
        "seven": 7,
        "eight": 8,
        "nine": 9
    }
    number_list = numbers.split()
    sorted_numbers = sorted(number_list, key=lambda x: number_map[x])
    return " ".join(sorted_numbers)

--------------------------------------------------
HumanEval/20

def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """
    Find the closest elements in a list of numbers and return them in order.

    Args:
        numbers (List[float]): A list of numbers.

    Returns:
        Tuple[float, float]: The two closest elements in the list in order.
    """
    # Sort the list
    sorted_numbers = sorted(numbers)

    # Initialize variables to keep track of the closest elements and their difference
    closest_elements = (sorted_numbers[0], sorted_numbers[1])
    min_diff = abs(closest_elements[0] - closest_elements[1])

    # Iterate over the list and find the closest elements
    for i in range(len(sorted_numbers) - 1):
        current_diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])
        if current_diff < min_diff:
            min_diff = current_diff
            closest_elements = (sorted_numbers[i], sorted_numbers[i + 1])

    return closest_elements

--------------------------------------------------
HumanEval/21

def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """
    # Step 1: Find the smallest and largest number in the list
    smallest = min(numbers)
    largest = max(numbers)

    # Step 2: Calculate the range of the numbers (largest - smallest)
    range = largest - smallest

    # Step 3: Create a new list to store the rescaled numbers
    rescaled_numbers = []

    # Step 4: Iterate through the original list and apply the linear transform
    for number in numbers:
        # Calculate the rescaled value using the linear formula: (number - smallest) / range
        rescaled_value = (number - smallest) / range
        rescaled_numbers.append(rescaled_

--------------------------------------------------
HumanEval/22

def filter_integers(values):
    integers = []
    for value in values:
        if isinstance(value, int):
            integers.append(value)
    return integers

--------------------------------------------------
HumanEval/23

def strlen(string: str) -> int:
    return len(string)

--------------------------------------------------
HumanEval/24

def largest_divisor(n):
    largest = 1
    for i in range(2, n//2+1):
        if n % i == 0:
            largest = i
    return largest

--------------------------------------------------
HumanEval/25

def factorize(n):
    if n <= 1:
        return []
    prime_factors = []
    for i in range(2, int(n**0.5) + 1):
        while n % i == 0:
            prime_factors.append(i)

--------------------------------------------------
HumanEval/26

def remove_duplicates(numbers: List[int]) -> List[int]:
    unique_elements = set()
    unique_list = []
    for num in numbers:
        if num not in unique_elements:
            unique_list.append(num)
            unique_elements.add(num)
    return unique_list

--------------------------------------------------
HumanEval/27

def flip_case(string):
    flipped_string = ""
    for char in string:
        if char.isupper():
            flipped_string += char.lower()
        else:
            flipped_string += char.upper()
    return flipped_string

--------------------------------------------------
HumanEval/28

def concatenate(strings: List[str]) -> str:
    """ Concatenate list of strings into a single string
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """
    result = ""
    for s in strings:
        result += s
    return result

--------------------------------------------------
HumanEval/29

def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """ Filter an input list of strings only for ones that start with a given prefix.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """
    filtered_strings = []
    for string in strings:
        if string.startswith(prefix):
            filtered_strings.append(string)
    return filtered_strings

--------------------------------------------------
HumanEval/30

def get_positive(l: list):
    return [x for x in l if x > 0]

--------------------------------------------------
HumanEval/31

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/32

import math

def find_zero(xs):
    # Check if xs has an even number of elements
    if len(xs) % 2 != 0:
        raise ValueError("The input list must have an even number of elements.")
    
    # Find the largest non-zero coefficient in xs
    max_coeff = max([abs(x) for x in xs])
    if max_coeff == 0:
        raise ValueError("The input list must have a non-zero coefficient.")
    
    # Use Newton-Raphson method to find a zero of the polynomial defined by xs
    x = 0
    while True:
        fx = poly(xs, x)
        if abs

--------------------------------------------------
HumanEval/33

def sort_third(l: list):
    # Create a copy of the original list
    l_copy = l.copy()
    # Get the length of the list
    n = len(l)
    # Iterate over the indicies that are divisible by three
    for i in range(0, n, 3):
        # Sort the values at the current index and the next two indices
        l_copy[i:i+3] = sorted(l_copy[i:i+3])
    return l_copy

--------------------------------------------------
HumanEval/34

def unique(my_list):
    return sorted(set(my_list))

--------------------------------------------------
HumanEval/35

def max_element(l):
    max_val = l[0]
    for i in range(1, len(l)):
        if l[i] > max_val:
            max_val = l[i]
    return max_val

--------------------------------------------------
HumanEval/36

def fizz_buzz(n):
    count = 0
    for i in range(1, n):
        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):
            count += 1
    return count

--------------------------------------------------
HumanEval/37

def sort_even(l: list):
    # Create a new list to store the sorted even indices
    l_sorted = []
    # Iterate over the indicies of the input list
    for i in range(len(l)):
        # If the index is even, add the value at that index to the sorted list
        if i % 2 == 0:
            l_sorted.append(l[i])
    # Sort the sorted list
    l_sorted.sort()
    # Iterate over the indicies of the input list again
    for i in range(len(l)):
        # If the index is even, replace the value at that index with the corresponding value from the sorted list
        if i % 2 == 0:
            l[i] = l_sorted[i // 2]
    # Return the modified input list
    return l

--------------------------------------------------
HumanEval/38

def decode_cyclic(s):
    # Split the input string into groups of three characters each
    groups = [s[i:i+3] for i in range(0, len(s), 3)]
    
    # For each group, move the last character to the front and shift the remaining characters one position to the right
    decoded_groups = []
    for group in groups:
        if len(group) == 3:
            decoded_groups.append(group[2:] + group[0])
        else:
            decoded_groups.append(group)
    
    # Join all the groups back together to form the decoded string
    return "".join(decoded_groups)

--------------------------------------------------
HumanEval/39

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_fib(n):
    fib = [0, 1]
    while len(fib) <= n:
        fib.append(fib[-1] + fib[-2])
    for i in range(len(fib)):
        if is_prime(fib[i]):

--------------------------------------------------
HumanEval/40

def triples_sum_to_zero(l: list):
    # Check if the list has at least three elements
    if len(l) < 3:
        return False

    # Sort the list
    l.sort()

    # Loop through the list and check for three elements that sum to zero
    for i in range(len(l) - 2):
        left = i + 1
        right = len(l) - 1
        while left < right:
            if l[i] + l[left] + l[right] == 0:
                return True
            elif l[i] + l[left] + l[right] < 0:
                left += 1
            else:
                right -= 1
    return False

--------------------------------------------------
HumanEval/41

def car_race_collision(n: int) -> int:
    # Initialize a counter for the number of collisions
    collision_count = 0

    # Iterate over each pair of cars moving in opposite directions
    for i in range(n):
        for j in range(n):
            # Check if the two cars are on opposite sides of the road
            if i + j == n - 1:
                collision_count += 1

    return collision_count

--------------------------------------------------
HumanEval/42

def incr_list(l: list):
    return [x + 1 for x in l]

--------------------------------------------------
HumanEval/43

def pairs_sum_to_zero(l):
    for i in range(len(l)):
        for j in range(i+1, len(l)):
            if l[i] + l[j] == 0:
                return True
    return False

--------------------------------------------------
HumanEval/44

def change_base(x, base):
    x_str = str(x)
    digits = []
    for digit in x_str:
        digits.append(str(int(digit) % base))
    return ''.join(digits)

--------------------------------------------------
HumanEval/45

def triangle_area(a, h):
    s = (a + h) / 2
    A = sqrt(s * (s - a) * (s - h))
    return A

--------------------------------------------------
HumanEval/46

def fib4(n: int):
    if n <= 3:
        return 0
    elif n == 4:
        return 2
    else:
        a, b, c, d = 0, 0, 2, 0
        for i in range(4, n+1):
            a, b, c, d = b, c, d, a + b + c + d
        return d

--------------------------------------------------
HumanEval/47

def median(l):
    if not l:
        return None
    sorted_list = sorted(l)
    if len(sorted_list) % 2 == 0:
        return (sorted_list[len(sorted_list) // 2 - 1] + sorted_list[len(sorted_list) // 2]) / 2
    else:
        return sorted_list[len(sorted_list) // 2]

--------------------------------------------------
HumanEval/48

def is_palindrome(text):
    if not text:
        return True
    reversed_text = text[::-1]
    return text == reversed_text

--------------------------------------------------
HumanEval/49

def modp(n, p):
    if n < 0:
        n = -n
        while n > 0:
            result = (result * result) % p
            n -= 1
        return result
    else:
        return pow(2, n, p)

--------------------------------------------------
HumanEval/50

def decode_shift(s: str):
    """
    takes as input string encoded with encode_shift function. Returns decoded string.
    """
    return "".join([chr(((ord(ch) - 5 - ord("a")) % 26) + ord("a")) for ch in s])

--------------------------------------------------
HumanEval/51

def remove_vowels(text):
    vowels = set('aeiou')  # define a set of vowels to remove
    output = ''             # initialize an empty output string
    for char in text:      # loop through each character in the input string
        if char not in vowels:  # check if the current character is not a vowel
            output += char   # add it to the output string
    return output           # return the modified output string without any vowels

--------------------------------------------------
HumanEval/52

def below_threshold(l: list, t: int) -> bool:
    return all(x < t for x in l)

--------------------------------------------------
HumanEval/53

def add(x: int, y: int) -> int:
    return x + y

--------------------------------------------------
HumanEval/54

def same_chars(word1, word2):
    return sorted(word1) == sorted(word2)

--------------------------------------------------
HumanEval/55

def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)

--------------------------------------------------
HumanEval/56

def correct_bracketing(brackets):
    stack = []
    for char in brackets:
        if char == "<":
            stack.append(char)
        elif char == ">":
            if not stack:
                return False
            stack.pop()
    return not stack

--------------------------------------------------
HumanEval/57

def monotonic(l):
    if len(l) <= 1:
        return True
    increasing = True
    decreasing = True
    for i in range(1, len(l)):
        if l[i] >= l[i-1]:
            increasing = False
        if l[i] <= l[i-1]:
            decreasing = False
    return not (increasing or decreasing)

--------------------------------------------------
HumanEval/58

def common(l1, l2):
    # Define a new list to store the common elements
    common_elements = []

    # Use a set to get the unique elements from both lists
    unique_elements = set(l1).intersection(set(l2))

    # Sort the resulting list of common elements
    sorted_common_elements = sorted(unique_elements)

    # Return the sorted list of common elements
    return sorted_common_elements

--------------------------------------------------
HumanEval/59

def largest_prime_factor(n):
    if is_prime(n):
        return n
    largest_factor = 1
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            largest_factor = max(largest_factor, i)
    return largest_factor

--------------------------------------------------
HumanEval/60

def sum_to_n(n):
    total = 0
    for i in range(1, n+1):
        total += i
    return total

--------------------------------------------------
HumanEval/61

def correct_bracketing(brackets):
    stack = []
    for char in brackets:
        if char == "(":
            stack.append(char)
        elif char == ")":
            if len(stack) == 0 or stack[-1] != "(":
                return False
            else:
                stack.pop()
    return len(stack) == 0

--------------------------------------------------
HumanEval/62

def derivative(xs: list):
    """ xs represent coefficients of a polynomial.
    xs[0] + xs[1] * x + xs[2] * x^2 + ....
     Return derivative of this polynomial in the same form.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """
    pass

--------------------------------------------------
HumanEval/63

def fibfib(n):
    fibfib_list = [0, 0, 1]
    for i in range(3, n+1):
        fibfib_list.append(fibfib_list[i-1] + fibfib_list[i-2] + fibfib_list[i-3])
    return fibfib_list[-1]

--------------------------------------------------
HumanEval/64

def vowels_count(word):
    vowels = {'a', 'e', 'i', 'o', 'u'}
    count = 0
    for char in word:
        if char in vowels:
            count += 1
    return count

--------------------------------------------------
HumanEval/65

def circular_shift(x, shift):
    x = str(x)
    length = len(x)
    if shift > length:
        return x[::-1]
    else:
        return x[shift:] + x[:shift]

--------------------------------------------------
HumanEval/66

def digitSum(s):
    result = 0
    for c in s:
        if c.isupper():
            result += ord(c)
    return result

--------------------------------------------------
HumanEval/67

def fruit_distribution(s, n):
    # Convert the string to a list of integers
    s = [int(x) for x in s.split()]
    # Calculate the number of mango fruits
    m = n - sum(s)
    return m

--------------------------------------------------
HumanEval/68

def pluck(arr):
    # Check if the input array is empty
    if not arr:
        return []

    # Initialize variables for the smallest even value and its index
    smallest_even = None
    smallest_index = None

    # Iterate over the input array
    for i, value in enumerate(arr):
        # Check if the current value is even
        if value % 2 == 0:
            # If the current value is even, check if it's smaller than the previous smallest even value
            if smallest_even is None or value < smallest_even:
                # If the current value is smaller, update the smallest even value and its index
                smallest_even = value
                smallest_index = i

    # Return the smallest even value and its index, or an empty list if no even values were found
    return [smallest_even, smallest_index] if smallest_even is not None else []

--------------------------------------------------
HumanEval/69

def search(lst):
    freq = {}
    for i in lst:
        if i not in freq:
            freq[i] = 0
        freq[i] += 1
    max_val = -1
    for key, val in freq.items():
        if val >= key and val > max_val:
            max_val = val
    return max_val

--------------------------------------------------
HumanEval/70

def strange_sort_list(lst):
    # Sort the input list using the built-in sorted function
    sorted_lst = sorted(lst)

    # Create a new empty list to store the sorted elements in the desired order
    result = []

    # Iterate over the sorted list and append the minimum value to the new list
    while len(sorted_lst) > 0:
        min_value = min(sorted_lst)
        result.append(min_value)
        sorted_lst.remove(min_value)

    # Return the new list with the sorted elements in the desired order
    return result

--------------------------------------------------
HumanEval/71

def triangle_area(a, b, c):
    if a + b <= c or a + c <= b or b + c <= a:
        return -1
    semi_perimeter = (a + b + c) / 2
    area = round(sqrt(semi_perimeter * (semi_perimeter - a) * (semi_perimeter - b) * (semi_perimeter - c)), 2)
    return area

--------------------------------------------------
HumanEval/72

def will_it_fly(q, w):
    # Check if q is a palindromic list
    if q == q[::-1]:
        # Check if the sum of elements in q is less than or equal to w
        if sum(q) <= w:
            return True
    return False

--------------------------------------------------
HumanEval/73

def smallest_change(arr):
    if len(arr) <= 1:
        return 0
    
    mid = len(arr) // 2
    first_half = arr[:mid]
    second_half = arr[mid:]
    
    # Check if the first half is a palindrome
    if not is_palindrome(first_half):

--------------------------------------------------
HumanEval/74

def total_match(lst1, lst2):
    total1 = 0
    total2 = 0
    for s in lst1:
        total1 += len(s)
    for s in lst2:
        total2 += len(s)
    if total1 < total2:
        return lst1
    elif total2 < total1:
        return lst2
    else:
        return lst1

--------------------------------------------------
HumanEval/75

def is_multiply_prime(a):
    if a <= 1 or a >= 100:
        return False
    for i in range(2, int(a**0.5) + 1):
        if a % i == 0 and is_prime(i) and is_prime(a//i):
            return True
    return False

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/76

def is_simple_power(x, n):
    return x == n ** int(n)

--------------------------------------------------
HumanEval/77

def iscube(a):
    if a == 0 or a == 1:
        return True
    cube_root = math.pow(a, 1/3)
    if cube_root**3 == a:
        return True
    else:
        return False

--------------------------------------------------
HumanEval/78

def hex_key(num):
    prime_digits = [2, 3, 5, 7, 11, 13]
    count = 0
    for char in num:
        if char in "0123456789":
            decimal_value = int(char)
        else:
            decimal_value = ord(char) - ord("A") + 10
        if decimal_value in prime_digits:
            count += 1
    return count

--------------------------------------------------
HumanEval/79

def decimal_to_binary(decimal):
    # Convert the input decimal number to a binary string
    binary = bin(decimal)

    # Remove the extra characters '0b' from the beginning and end of the binary string
    binary = binary[2:]

    # Add the extra characters 'db' at the beginning and end of the binary string
    binary = "db" + binary + "db"

    return binary

--------------------------------------------------
HumanEval/80

def is_happy(s):
    if len(s) < 3:
        return False
    seen = set()
    for i in range(0, len(s), 3):
        chunk = s[i:i+3]
        if any(letter in seen for letter in chunk):
            return False
        seen.update(chunk)
    return True

--------------------------------------------------
HumanEval/81

def numerical_letter_grade(grades):
    grade_map = {4.0: "A+", 3.7: "A", 3.3: "A-", 3.0: "B+", 2.7: "B", 2.3: "B-", 2.0: "C+", 1.7: "C", 1.3: "C-", 1.0: "D+", 0.7: "D", 0.0: "D-", 0.0: "E"}
    return [grade_map[grade] for grade in grades]

--------------------------------------------------
HumanEval/82

def prime_length(string):
    prime_numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
    return len(string) in prime_numbers

--------------------------------------------------
HumanEval/83

def starts_one_ends(n):
    count = 0
    for i in range(10**(n-1), 10**n):
        if str(i)[0] == '1' or str(i)[-1] == '1':
            count += 1
    return count

--------------------------------------------------
HumanEval/84

def solve(N):
    # Convert the input integer to a binary string
    binary_string = bin(N)[2:]
    
    # Initialize the total sum variable
    total_sum = 0
    
    # Iterate through each digit in the binary string
    for digit in binary_string:
        # Convert the current digit to an integer and add it to the total sum
        total_sum += int(digit)
    
    # Return the total sum as a binary string
    return bin(total_sum)[2:]

--------------------------------------------------
HumanEval/85

def add(lst):
    result = 0
    for i in range(len(lst)):
        if i % 2 == 1 and lst[i] % 2 == 0:
            result += lst[i]
    return result

--------------------------------------------------
HumanEval/86

def anti_shuffle(s):
    words = s.split()
    ordered_words = []
    for word in words:
        ordered_word = ''.join(sorted(word))
        ordered_words.append(ordered_word)
    return ' '.join(ordered_words)

--------------------------------------------------
HumanEval/87

def get_row(lst, x):
    result = []
    for i in range(len(lst)):
        for j in range(len(lst[i])):
            if lst[i][j] == x:
                result.append((i, j))
    return sorted(result)

--------------------------------------------------
HumanEval/88

def sort_array(array):
    # Create a copy of the given array
    arr = array[:]
    # Calculate the sum of the first and last index values
    sum = arr[0] + arr[-1]
    # Check if the sum is odd or even
    if sum % 2 == 1:
        # Sort the array in ascending order
        arr.sort()
    else:
        # Sort the array in descending order
        arr.sort(reverse=True)
    return arr

--------------------------------------------------
HumanEval/89

def encrypt(s):
    # Define a dictionary to map letters to their encrypted values
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    encrypted_alphabet = 'cdefghijklmnopqrstuvwxyzab'
    letter_map = {letter: encrypted_alphabet[i] for i, letter in enumerate(alphabet)}
    
    # Encrypt the input string
    encrypted_string = ''
    for char in s:
        if char.isalpha():
            encrypted_string += letter_map[char]
        else:
            encrypted_string += char
    
    return encrypted_string

--------------------------------------------------
HumanEval/90

def next_smallest(lst):
    sorted_list = sorted(lst)
    smallest_index = sorted_list.index(min(sorted_list))
    if smallest_index < len(sorted_list) - 1:
        return sorted_list[smallest_index + 1]
    else:
        return None

--------------------------------------------------
HumanEval/91

def is_bored(S):
    # Step 1: Split the input string into sentences using '.', '?' or '!' as delimiters.
    sentences = S.split('.')
    sentences += S.split('?')
    sentences += S.split('!')
    
    # Step 2: Loop through each sentence and check if it starts with "I".
    boredom_count = 0
    for sentence in sentences:
        if sentence.startswith("I"):
            boredom_count += 1
    
    # Step 3: Return the number of boredoms found.
    return boredom_count

--------------------------------------------------
HumanEval/92

def any_int(x, y, z):
    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):
        return False
    sum = x + y
    if z == sum:
        return True
    else:
        return False

--------------------------------------------------
HumanEval/93

def encode(message):
    # Create a dictionary to map vowels to their replacement letters
    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'm', 'u': 'q'}
    # Initialize an empty string to store the encoded message
    encoded_message = ''
    # Iterate through each letter in the message
    for letter in message:
        # If the letter is a vowel, replace it with its corresponding replacement letter
        if letter.lower() in vowel_map:
            encoded_message += vowel_map[letter.lower()].upper()
        # Otherwise, swap the case of the letter and add it to the encoded message
        else:
            encoded_message += letter.swapcase()
    return encoded_message

--------------------------------------------------
HumanEval/94

def skjkasdkd(lst):
    # Step 1: Create a function to find the largest prime number in the list
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    largest_prime = None
    for num in lst:
        if is_prime(num) and (largest_prime is None or num > largest_prime):
            largest_prime = num

    # Step 2: Sum the digits of the largest prime number
    if largest_prime is not None:
        return sum(int(digit) for digit in str(largest_prime))
    else:
        return 0

--------------------------------------------------
HumanEval/95

def check_dict_case(dictionary):
    if not dictionary:
        return False
    first_key = list(dictionary.keys())[0]
    if not isinstance(first_key, str):
        return False
    lower_case_first_key = first_key.lower()
    for key in dictionary.keys():
        if not isinstance(key, str) or key.lower() != lower_case_first_key:
            return False
    return True

--------------------------------------------------
HumanEval/96

def count_up_to(n):
    """Implement a function that takes an non-negative integer and returns an array of the first n
    integers that are prime numbers and less than n.
    for example:
    count_up_to(5) => [2,3]
    count_up_to(11) => [2,3,5,7]
    count_up_to(0) => []
    count_up_to(20) => [2,3,5,7,11,13,17,19]
    count_up_to(1) => []
    count_up_to(18) => [2,3,5,7,11,13,17]
    """
    prime_numbers = []
    for i in range(2, n+1):
        if is_prime(i

--------------------------------------------------
HumanEval/97

def multiply(a, b):
    unit_digit_a = a % 10
    unit_digit_b = b % 10
    return unit_digit_a * unit_digit_b

--------------------------------------------------
HumanEval/98

def count_upper(s):
    count = 0
    for i, c in enumerate(s):
        if c.isupper() and i % 2 == 0:
            count += 1
    return count

--------------------------------------------------
HumanEval/99

def closest_integer(value):
    float_value = float(value)
    rounded_value = round(float_value)
    if rounded_value != float_value:
        rounded_value += 0.5
    return int(rounded_value)

--------------------------------------------------
HumanEval/100

def make_a_pile(n):
    result = []
    while n > 0:
        result.append(n)
        if n % 2 == 0:
            n //= 2
        else:
            n = (n + 1) // 2
    return result[::-1]

--------------------------------------------------
HumanEval/101

def words_string(s):
    words = []
    for word in s.split(", "):
        words.append(word)
    return words

--------------------------------------------------
HumanEval/102

def choose_num(x, y):
    """This function takes two positive numbers x and y and returns the
    biggest even integer number that is in the range [x, y] inclusive. If 
    there's no such number, then the function should return -1.

    For example:
    choose_num(12, 15) = 14
    choose_num(13, 12) = -1
    """
    if x <= 0 or y <= 0:
        return -1
    for i in range(x, y+1):
        if i % 2 == 0:
            return i
    return -1

--------------------------------------------------
HumanEval/103

def rounded_avg(n, m):
    if n > m:
        return -1
    total = 0
    for i in range(n, m+1):
        total += i
    average = round(total / (m-n+1))
    binary = bin(average)[2:]
    return binary

--------------------------------------------------
HumanEval/104

def unique_digits(x):
    # Step 1: Create an empty list to store the unique digits
    unique_list = []
    
    # Step 2: Iterate through each element in the input list
    for num in x:
        # Step 3: Check if the current number has any even digits
        if not any(int(digit) % 2 == 0 for digit in str(num)):
            # Step 4: If the current number has no even digits, add it to the unique list
            unique_list.append(num)
    
    # Step 5: Return the sorted unique list
    return sorted(unique_list)

--------------------------------------------------
HumanEval/105

def by_length(arr):
    # Step 1: Sort the array in ascending order
    arr.sort()
    # Step 2: Reverse the sorted array
    arr.reverse()
    # Step 3: Replace each digit with its corresponding name
    for i in range(len(arr)):
        if arr[i] == 1:
            arr[i] = "One"
        elif arr[i] == 2:
            arr[i] = "Two"
        elif arr[i] == 3:
            arr[i] = "Three"
        elif arr[i] == 4:
            arr[i] = "Four"
        elif arr[i] == 5:
            arr[i] = "Five"
        elif arr[i] == 6:
            arr[i] = "Six"
        elif arr[i] == 7:
            arr[i] = "Seven"
        elif arr[i] == 8:
            arr[i] = "Eight"
        elif arr[i] == 9:
            arr[i] = "Nine"
    return arr

--------------------------------------------------
HumanEval/106

def f(n):
    if n < 0:
        raise ValueError("Invalid input parameter n")
    results = []
    for i in range(1, n+1):
        if i % 2 == 0:
            factorial = 1
            for j in range(1, i+1):
                factorial *= j
            results.append(factorial)
        else

--------------------------------------------------
HumanEval/107

def even_odd_palindrome(n):
    even_count = 0
    odd_count = 0
    for i in range(1, n+1):
        if is_palindrome(i):
            if i % 2 == 0:
                even_count += 1
            else:
                odd_count += 1
    return (even_count, odd_count)

def is_palindrome(n):
    return str(n) == str(n)[::-1]

--------------------------------------------------
HumanEval/108

def count_nums(arr):
    count = 0
    for num in arr:
        sum_of_digits = 0
        for digit in str(abs(num)):
            sum_of_digits += int(digit)
        if sum_of_digits > 0:
            count += 1
    return count

--------------------------------------------------
HumanEval/109

def move_one_ball(arr):
    # Check if the input array is empty
    if not arr:
        return True
    # Initialize a variable to keep track of the number of elements that are in their correct position
    num_correct = 0
    # Loop through the input array
    for i in range(len(arr)):
        # Check if the current element is in its correct position
        if arr[i] == i + 1:
            # If it is, increment the number of elements that are in their correct position
            num_correct += 1
    # Return True if all elements are in their correct position, False otherwise
    return num_correct == len(arr)

--------------------------------------------------
HumanEval/110

def exchange(lst1, lst2):
    # Step 1: Check if all elements in lst1 are even
    for i in range(len(lst1)):
        if lst1[i] % 2 == 1:
            return "NO"
    # Step 2: Check if there are any even numbers in lst2
    for i in range(len(lst2)):
        if lst2[i] % 2 == 0:
            # Step 3: If there is an even number in lst2, exchange it with the first odd number in lst1
            lst1[0], lst2[i] = lst2[i], lst1[0]
            return "YES"
    # Step 4: If there are no even numbers in lst2, return "NO"
    return "NO"

--------------------------------------------------
HumanEval/111

def histogram(test):
    """Given a string representing a space separated lowercase letters, return a dictionary
    of the letter with the most repetition and containing the corresponding count.
    If several letters have the same occurrence, return all of them.
    
    Example:
    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}
    histogram('a b b a') == {'a': 2, 'b': 2}
    histogram('a b c a b') == {'a': 2, 'b': 2}
    histogram('b b b b a') == {'b': 4}
    histogram('') == {}

    """
    # Create an empty dictionary to store the counts
    letter_counts = {}
    
    # Split the input string into individual letters
    letters = test.split()
    
    # Iterate over the letters and increment the count for each one
    for letter in letters:
        if letter not in letter_counts:
            letter_counts[letter] = 1
        else:
            letter_counts[letter] += 1
    
    # Find the letter with the highest count
    max_count = max(letter_counts

--------------------------------------------------
HumanEval/112

def reverse_delete(s, c):
    # Step 1: Delete all characters in s that are equal to any character in c
    for char in c:
        s = s.replace(char, "")
    # Step 2: Check if the result string is palindrome
    return (s, s == s[::-1])

--------------------------------------------------
HumanEval/113

def odd_count(lst):
    result = []
    for s in lst:
        count = 0
        for c in s:
            if int(c) % 2 == 1:
                count += 1
        result.append("the number of odd elements " + str(count) + "n the str" + str(count) + "ng " + str(count) + " of the " + str(count) + "nput.")
    return result

--------------------------------------------------
HumanEval/114

def minSubArraySum(nums):
    min_sum = float('inf')
    for i in range(len(nums)):
        current_sum = 0
        for j in range(i, len(nums)):
            current_sum += nums[j]
            if current_sum < min_sum:
                min_sum = current_sum
    return min_sum

--------------------------------------------------
HumanEval/115

def max_fill(grid, capacity):
    rows = len(grid)
    cols = len(grid[0])
    water = 0
    count = 0

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1:
                water += 1
                grid[i][j] = 0
                count += 1
            if water == capacity:
                water = 0
                break
        if water > 0 and j < cols - 1:
            for k in range(j+1, cols):
                if grid[i][k] == 1:
                    water += 1
                    grid[i][k] = 0
                    count += 1
                if water == capacity:
                    water = 0
                    break
        if water > 0 and i < rows - 1:
            for k in range(i+1, rows):
                if grid[k][j] == 1:
                    water += 1
                    grid[k][j] = 0
                    count += 1
                if water == capacity:
                    water = 0
                    break

    return count

--------------------------------------------------
HumanEval/116

def sort_array(arr):
    # Step 1: Convert each integer to its binary representation
    binary_list = []
    for num in arr:
        binary_list.append(bin(num)[2:])

    # Step 2: Count the number of ones in each binary representation
    count_list = []
    for binary_str in binary_list:
        count = 0
        for char in binary_str:
            if char == "1":
                count += 1
        count_list.append(count)

    # Step 3: Sort the list by number of ones, and then by decimal value
    sorted_list = sorted(arr, key=lambda x: (count_list[x], x))

    return sorted_list

--------------------------------------------------
HumanEval/117

def select_words(s, n):
    words = s.split()
    result = []
    for word in words:
        if len(word) == n:
            result.append(word)
    return result

--------------------------------------------------
HumanEval/118

def get_closest_vowel(word):
    closest_vowel = ""
    for char in reversed(word):
        if char not in "aeiou":
            continue
        if char != word[0] and char != word[-1]:
            closest_vowel = char
            break
    return closest_vowel

--------------------------------------------------
HumanEval/119

def match_parens(lst):
    # Check if the length of both strings is even
    if len(lst[0]) % 2 != 0 or len(lst[1]) % 2 != 0:
        return "No"
    
    # Create a stack to keep track of the parentheses
    stack = [lst[0][0]]
    
    # Iterate through the second string and check for balanced parentheses
    for char in lst[1]:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if len(stack) == 0:

--------------------------------------------------
HumanEval/120

def maximum(arr, k):
    return sorted(arr, reverse=True)[:k]

--------------------------------------------------
HumanEval/121

def solution(lst):
    sum = 0
    for i in range(len(lst)):
        if lst[i] % 2 == 0 and i % 2 == 1:
            sum += lst[i]
    return sum

--------------------------------------------------
HumanEval/122

def add_elements(arr, k):
    # Step 1: Sort the input array in ascending order
    arr.sort()
    # Step 2: Initialize a variable to store the sum
    sum = 0
    # Step 3: Iterate over the first k elements of the sorted array
    for i in range(k):
        # Step 4: Check if the current element has at most two digits
        if len(str(arr[i])) <= 2:
            # Step 5: Add the current element to the sum
            sum += arr[i]
    # Step 6: Return the sum
    return sum

--------------------------------------------------
HumanEval/123

def get_odd_collatz(n):
    if n <= 0:
        raise ValueError("n must be a positive integer")
    
    # Initialize an empty list to store the odd numbers in the Collatz sequence
    odd_numbers = []
    
    # Set the current number to n
    current_number = n
    
    # Loop until the current number is 1
    while current_number != 1:
        # If the current number is even, divide it by 2
        if current_number % 2 == 0:
            current_number //= 2
        # If the current number is odd, multiply it by 3 and add 1
        else:
            current_number = 3 * current_number + 1
        
        # If the current number is odd, add it to the list of odd numbers
        if current_number % 2 == 1:
            odd_numbers.append(current_number)
    
    # Return the sorted list of odd numbers
    return sorted(odd_numbers)

--------------------------------------------------
HumanEval/124

def valid_date(date):
    # Check if the date string is empty
    if not date:
        return False

    # Split the date into month, day, and year
    month, day, year = date.split('-')

    # Check if the month is valid
    if int(month) < 1 or int(month) > 12:
        return False

    # Check if the day is valid
    if int(day) < 1 or int(day) > 31:
        return False

    # Check if the year is valid
    if int(year) < 0 or len(str(year)) != 4:
        return False

    # Check if the date is in the format mm-dd-yyyy
    if not re.match(r'^\d{2}-\d{2}-\d{4}$', date):
        return False

    # Check if the day is valid for the month
    if int(month) in [1, 3, 5, 7, 8, 10, 12] and int(day) > 31:
        return False
    elif int(month) in [4, 6, 9, 11] and int(day) > 3

--------------------------------------------------
HumanEval/125

def split_words(txt):
    # Check if there are any whitespace characters in the input string
    if txt.isspace():
        return txt.split()
    
    # Check if there are any commas in the input string
    elif ',' in txt:
        return txt.split(',')
    
    # If neither whitespace nor comma characters exist, return the number of lower-case letters with odd order in the alphabet
    else:
        count = 0
        for c in txt:
            if ord(

--------------------------------------------------
HumanEval/126

def is_sorted(lst):
    # Check if list contains duplicates
    if len(lst) != len(set(lst)):
        return False
    # Check if list is sorted in ascending order
    for i in range(len(lst) - 1):
        if lst[i] > lst[i + 1]:
            return False
    return True

--------------------------------------------------
HumanEval/127

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def intersection(interval1, interval2):
    intersection = (max(interval1[0], interval

--------------------------------------------------
HumanEval/128

def prod_signs(arr):
    if not arr:
        return None
    signs = []
    for num in arr:
        if num > 0:
            signs.append(1)
        elif num < 0:
            signs.append(-1)
        else:
            signs.append(0)
    product = 1
    for sign in signs:
        product *= sign
    return sum(arr) * product

--------------------------------------------------
HumanEval/129

def minPath(grid, k):
    # Initialize the minimum path length to infinity
    min_path_len = float('inf')
    # Initialize the minimum path
    min_path = []
    # Loop through each cell in the grid
    for i in range(len(grid)):
        for j in range(len(grid[i])):
            # Calculate the length of the path from the current cell to the destination cell
            path_len = len(findPath(grid, i, j, k))
            # If the path length is less than the minimum path length, update the minimum path length and minimum path
            if path_len < min_path_len:
                min_path_len = path_len
                min_path = findPath(grid, i, j, k)
    # Return the minimum path
    return min_path

def findPath(grid, row, col, k):
    # Base case: If the destination cell has been reached, return the path
    if grid[row][col] == k:
        return [k]
    # Initialize the path to empty
    path = []
    # Loop through each neighbor of the current cell
    for i in range(max(0, row-1), min(len(grid)-1, row+1

--------------------------------------------------
HumanEval/130

def tri(n):
    if n == 0:
        return [0]
    elif n == 1:
        return [0, 3]
    else:
        result = [0, 3]
        for i in range(2, n+1):
            if i % 2 == 0:
                result.append(result[i-1] + (i/2))
            else:
                result.append(result[i-2] + result[i-1] + result[i+1])
        return result

--------------------------------------------------
HumanEval/131

def digits(n):
    result = 1
    while n > 0:
        if n % 2 == 1:
            result *= n % 10
        n //= 10
    return result

--------------------------------------------------
HumanEval/132

def is_nested(string):
    # Check if the input string contains only square brackets
    if not all(c == '[' or c == ']' for c in string):
        return False
    
    # Initialize a stack to keep track of opening brackets
    stack = []
    
    # Iterate through the input string and check each character
    for char in string:
        if char == '[':
            # Push opening bracket onto the stack
            stack.append(char)
        elif char == ']':
            # Pop top element from the stack
            if not stack:
                return False
            stack.pop()
    
    # If the

--------------------------------------------------
HumanEval/133

import math

def sum_squares(lst):
    total = 0
    for elem in lst:
        rounded_elem = math.ceil(elem)
        squared_elem = rounded_elem ** 2
        total += squared_elem
    return total

--------------------------------------------------
HumanEval/134

def check_if_last_char_is_a_letter(txt):
    # Check if the last character is a letter
    if txt[-1].isalpha():
        # Check if the last character is not part of a word
        if txt[-1] != " ":
            return True
    return False

--------------------------------------------------
HumanEval/135

def can_arrange(arr):
    largest = -1
    for i in range(len(arr)):
        if arr[i] < arr[i-1]:
            largest = i
            break
    return largest

--------------------------------------------------
HumanEval/136

def largest_smallest_integers(lst):
    if len(lst) <= 1:
        return (None, None)

    largest_negative = None
    smallest_positive = None

    for num in lst:
        if num < 0 and (largest_negative is None or num > largest_negative):
            largest_negative = num
        elif num > 0 and (smallest_positive is None or num < smallest_positive):
            smallest_positive = num

    return (largest_negative, smallest_positive)

--------------------------------------------------
HumanEval/137

def compare_one(a, b):
    # Convert all inputs to floats
    a = float(a)
    b = float(b)

    # Check if the values are equal
    if a == b:
        return None

    # Return the larger value in its original type
    if a > b:
        return a
    else:
        return b

--------------------------------------------------
HumanEval/138

def is_equal_to_sum_even(n):
    even_numbers = []
    for i in range(2, int(n**0.5) + 1):
        if i % 2 == 0:
            even_numbers.append(i)
    if len(even_numbers) != 4:
        return False
    return sum(even_numbers) == n

--------------------------------------------------
HumanEval/139

def special_factorial(n):
    if not isinstance(n, int) or n < 0:
        raise ValueError("Input must be a positive integer")
    result = 1
    for i in range(n, 0, -1):
        result *= factorial(i)
    return result

--------------------------------------------------
HumanEval/140

def fix_spaces(text):
    # Replace all spaces with underscores
    text = text.replace(" ", "_")
    
    # Check if there are more than two consecutive spaces
    if text.count("__") > 2:
        # Replace all consecutive spaces with a hyphen
        text = text.replace("__", "-")
    
    return text

--------------------------------------------------
HumanEval/141

def file_name_check(file_name):
    # Check for more than three digits
    if len([c for c in file_name if c.isdigit()]) > 3:
        return 'No'
    
    # Check for a dot
    if '.' not in file_name:
        return 'No'
    
    # Check if the substring before the dot starts with a letter from the Latin alphabet
    if not file_name.split('.')[0].isalpha():
        return 'No'
    
    # Check if the substring after the dot is one of the allowed extensions
    if file_name

--------------------------------------------------
HumanEval/142

def sum_squares(lst):
    result = 0
    for i in range(len(lst)):
        if i % 3 == 0:
            result += lst[i] ** 2
        elif i % 4 == 0:
            result += lst[i] ** 3
        else:
            result += lst[i]
    return result

--------------------------------------------------
HumanEval/143

def words_in_sentence(sentence):
    words = sentence.split()
    prime_words = []
    for word in words:
        if is_prime(len(word)):
            prime_words.append(word)
    return " ".join(prime_words)

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/144

def simplify(x, n):
    # Parse the input strings to extract the numerator and denominator
    x_num, x_den = map(int, x.split('/'))
    n_num, n_den = map(int, n.split('/'))

    # Calculate the least common multiple (LCM) of the two denominators
    lcm = x_den * n_den // math.gcd(x_den, n_den)

    # Multiply both numerators by the LCM and compare with the product of the two denominators
    return (lcm * x_num == lcm * n_num) and (lcm * x_den == lcm * n_den)

--------------------------------------------------
HumanEval/145

def order_by_points(nums):
    # Step 1: Calculate the sum of digits for each number
    nums_sum = [(sum(map(int, str(n))), n) for n in nums]

    # Step 2: Sort the list by the sum of digits
    nums_sum.sort()

    # Step 3: Return the sorted list
    return [n for _, n in nums_sum]

--------------------------------------------------
HumanEval/146

def specialFilter(nums):
    count = 0
    for num in nums:
        if num > 10 and num % 10 in [1, 3, 5, 7, 9]:
            count += 1
    return count

--------------------------------------------------
HumanEval/147

def get_max_triples(n):
    a = []
    for i in range(1, n+1):
        a.append(i*i - i + 1)
    count = 0
    for i in range(len(a)):
        for j in range(i+1, len(a)):
            for k in range(j+1, len(a)):
                if (a[i] + a[j] + a[k]) % 3 == 0:
                    count += 1
    return count

--------------------------------------------------
HumanEval/148

def bf(planet1, planet2):
    planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
    if planet1 not in planets or planet2 not in planets:
        return ()
    idx1 = planets.index(planet1)
    idx2 = planets.index(planet2)
    if idx1 < idx2:
        return tuple(planets[idx1+1:idx2])
    else:
        return tuple(planets[idx1-1::-1] + planets[:idx2+1])

--------------------------------------------------
HumanEval/149

def sorted_list_sum(lst):
    # Step 1: Filter out strings with odd lengths
    filtered_list = filter(lambda x: len(x) % 2 == 0, lst)
    # Step 2: Sort the list by length of each word
    sorted_list = sorted(filtered_list, key=len)
    # Step 3: Return the sorted list
    return sorted_list

--------------------------------------------------
HumanEval/150

def x_or_y(n, x, y):
    if not is_prime(n):
        return y
    else:
        return x

# Test cases
print(x_or_y(7, 34, 12)) # Output: 34
print(x_or_y(15, 8, 5)) # Output: 5

--------------------------------------------------
HumanEval/151

def double_the_difference(lst):
    if not lst:
        return 0
    total = 0
    for num in lst:
        if num % 2 != 0:
            total += num ** 2
    return total

--------------------------------------------------
HumanEval/152

def compare(game, guess):
    return [abs(g - s) for g, s in zip(guess, game)]

--------------------------------------------------
HumanEval/153

def Strongest_Extension(class_name, extensions):
    strengths = []
    for extension in extensions:
        cap = sum(1 for c in extension if c.isupper())
        sm = sum(1 for c in extension if c.islower())
        strengths.append((extension, cap - sm))
    return class_name + "." + max(strengths, key=lambda x: x[1])[0]

--------------------------------------------------
HumanEval/154

def cycpattern_check(a, b):
    def is_rotation(word1, word2):
        return word2 in word1 + word1
    
    if any(is_rotation(b, rotation) for rotation in a):
        return True
    else:
        return False

--------------------------------------------------
HumanEval/155

def even_odd_count(num):
    if num < 0:
        num *= -1
    even_count = 0
    odd_count = 0
    while num > 0:
        digit = num % 10
        if digit % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
        num //= 10
    return (even_count, odd_count)

--------------------------------------------------
HumanEval/156

def int_to_mini_roman(number):
    """
    Given a positive integer, obtain its roman numeral equivalent as a string,
    and return it in lowercase.
    Restrictions: 1 <= num <= 1000

    Examples:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """
    roman_numerals = {
        '1': 'i',
        '2': 'ii',
        '3': 'iii',
        '4': 'iv',
        '5': 'v',

--------------------------------------------------
HumanEval/157

def right_angle_triangle(a, b, c):
    # Check if the sum of any two sides is equal to the third side
    if a + b != c and a + c != b and b + c != a:
        return False
    
    # Check if the square of the length of one side is equal to the sum of the squares of the other two sides
    if a**2 == b**2 + c**2 or b**2 == a**2 + c**2 or c**2 == a**2 + b**2:
        return True
    
    # If neither condition is met, then the triangle is not a right-angled triangle
    return False

--------------------------------------------------
HumanEval/158

def find_max(words):
    # Create a dictionary to store the word and its unique character count
    word_count = {}
    
    # Iterate over the list of words
    for word in words:
        # Calculate the number of unique characters in the word
        unique_chars = set(word)
        num_unique_chars = len(unique_chars)
        
        # Check if the word is already in the dictionary
        if word not in word_count:
            # If not, add it to the dictionary with its unique character count
            word_count[word] = num_unique_chars
        else:
            # If it is already in the dictionary, check if the current count is higher
            if num_unique_chars > word_count[word]:
                # If it is, update the count
                word_count[word] = num_unique_chars
    
    # Find the word with the highest unique character count
    max_word = max(word_count, key=word_count.get)
    
    return max_word

--------------------------------------------------
HumanEval/159

def eat(number, need, remaining):
    total_eaten = number + need
    carrots_left = remaining - need
    if carrots_left < 0:
        carrots_left = 0
    return [total_eaten, carrots_left]

--------------------------------------------------
HumanEval/160

  To implement this function in Python, we can follow these steps:

1. Define the function with the appropriate parameters: `def do_algebra(operator, operand):`
2. Check if the length of the operator list is equal to the length of the operand list minus one: `if len(operator) != len(operand) - 1:`
3. If the condition in step 2 is not met, raise an error: `raise ValueError("Invalid input")`
4. Initialize a variable to store the result: `result = 0`
5. Loop through each element in the operator list and perform the corresponding operation on the operand list:
	* If the current operator is '+', add the current operand to the result: `result += operand[i]`
	* If the current operator is '-', subtract the current operand from the result: `result -= operand[i]`
	* If the current operator is '*', multiply the current operand by the result: `result *= operand[i]`
	* If the current operator is '/', divide the result by the current operand: `result /= operand[i]`
	* If the current operator is '**', raise the result to the power of the current operand: `result **= operand[i]`
6. Return the final result: `return result`


--------------------------------------------------
HumanEval/161

def solve(s):
    if not any(c.isalpha() for c in s):
        return s[::-1]
    else:
        result = ""
        for c in s:
            if c.isalpha():
                result += c.swapcase()
            else:
                result += c
        return result

--------------------------------------------------
HumanEval/162

import hashlib

def string_to_md5(text):
    """
    Given a string 'text', return its md5 hash equivalent string.
    If 'text' is an empty string, return None.

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """
    if not text:
        return None
    md5 = hashlib.md5()
    md5.update(text.encode('utf-8'))
    return md5.hexdigest()

--------------------------------------------------
HumanEval/163

def generate_integers(a, b):
    even_digits = []
    for i in range(a, b+1):
        if i % 2 == 0:
            even_digits.append(i)
    return sorted(even_digits)

--------------------------------------------------
