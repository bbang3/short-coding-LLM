HumanEval/0

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if abs(numbers[i] - numbers[j]) <= threshold:
                return True
    return False

--------------------------------------------------
HumanEval/1

def separate_paren_groups(paren_string):
    open_brace = 0
    start_index = 0
    result = []
    for i, char in enumerate(paren_string):
        if char == '(':
            if open_brace == 0:
                start_index = i
            open_brace += 1
        elif char == ')':
            open_brace -= 1
            if open_brace == 0:
                result.append(paren_string[start_index:i+1])
    return result

--------------------------------------------------
HumanEval/2

def truncate_number(number: float) -> float:
    """ Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    >>> truncate_number(3.5)
    0.5
    """
    return number - int(number)

--------------------------------------------------
HumanEval/3

def below_zero(operations: List[int]) -> bool:
    balance = 0
    for operation in operations:
        balance += operation
        if balance < 0:
            return True
    return False

--------------------------------------------------
HumanEval/4

def mean_absolute_deviation(numbers: List[float]) -> float:
    mean = sum(numbers) / len(numbers)
    return sum([abs(x - mean) for x in numbers]) / len(numbers)

--------------------------------------------------
HumanEval/5

def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    return [x for pair in zip(numbers[::2], numbers[1::2]) for x in pair] + numbers[-1:]

--------------------------------------------------
HumanEval/6

def parse_nested_parens(paren_string: str) -> List[int]:
    """
    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.
    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """
    def parse_parens(s: str) -> int:
        level = 0
        max_level = 0
        for c in s:
            if c == '(':
                level += 1
                max_level = max(max_level, level)
            elif c == ')':
                level -= 1
        return max_level

    return [parse_parens(s) for s in paren_string.split()]

--------------------------------------------------
HumanEval/7

def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    return [s for s in strings if substring in s]

--------------------------------------------------
HumanEval/8

def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """
    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    """
    sum = 0
    product = 1
    for num in numbers:
        sum += num
        product *= num
    return sum, product

--------------------------------------------------
HumanEval/9

def rolling_max(numbers: List[int]) -> List[int]:
    """
    Given a list of integers, generate a list of rolling maximum element found until given moment in the sequence.
    """
    max_value = 0
    result = []
    for num in numbers:
        if num > max_value:
            max_value = num
        result.append(max_value)
    return result

--------------------------------------------------
HumanEval/10

def is_palindrome(string: str) -> bool:
    """Test if given string is a palindrome"""
    return string == string[::-1]

def make_palindrome(string: str) -> str:
    """Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    """
    if not string or len(string) == 1:
        return string

    # find the longest postfix of supplied string that is a palindrome
    postfix_start = 0
    for i in range(len(string) - 1, 0, -1):
        if is_palindrome(string[i:]):
            postfix_start = i
            break

    # append to the end of the string reverse of a string prefix that comes before the palindromic suffix
    return string + string[postfix_start:len(string) - 1][::-1]

--------------------------------------------------
HumanEval/11

def string_xor(a: str, b: str) -> str:
    """
    Input are two strings a and b consisting only of 1s and 0s. Perform binary XOR on these inputs and return result also as a string.
    >>> string_xor('010', '110')
    '100'
    """
    result = ''
    for i in range(len(a)):
        if a[i] == b[i]:
            result += '0'
        else:
            result += '1'
    return result

--------------------------------------------------
HumanEval/12

def longest(strings: List[str]) -> Optional[str]:
    if not strings:
        return None
    return max(strings, key=len)

--------------------------------------------------
HumanEval/13

def greatest_common_divisor(a, b):
    while b:
        a, b = b, a % b
    return a

--------------------------------------------------
HumanEval/14

def all_prefixes(string: str) -> List[str]:
    """
    Return a list of all prefixes of the input string, from shortest to longest.

    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """
    return [string[:i+1] for i in range(len(string))]

--------------------------------------------------
HumanEval/15

def string_sequence(n: int) -> str:
    return " ".join(str(i) for i in range(n+1))

--------------------------------------------------
HumanEval/16

def count_distinct_characters(string: str) -> int:
    return len(set(string.lower()))

--------------------------------------------------
HumanEval/17

def parse_music(music_string: str) -> List[int]:
    """
    Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat
    """
    note_map = {
        'o': 4,
        'o|': 2,
        '.|': 1
    }
    return [note_map[note] for note in music_string.split()]

--------------------------------------------------
HumanEval/18

def how_many_times(string, substring):
    count = 0
    for i in range(len(string)):
        if string[i:i+len(substring)] == substring:
            count += 1
    return count

--------------------------------------------------
HumanEval/19

def sort_numbers(numbers: str) -> str:
    number_map = {
        "zero": 0,
        "one": 1,
        "two": 2,
        "three": 3,
        "four": 4,
        "five": 5,
        "six": 6,
        "seven": 7,
        "eight": 8,
        "nine": 9
    }
    number_list = numbers.split()
    sorted_numbers = sorted(number_list, key=lambda x: number_map[x])
    return " ".join(sorted_numbers)

--------------------------------------------------
HumanEval/20

def find_closest_elements(numbers):
    closest_pair = (numbers[0], numbers[1])
    smallest_diff = abs(closest_pair[0] - closest_pair[1])

    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            pair = (numbers[i], numbers[j])
            diff = abs(pair[0] - pair[1])
            if diff < smallest_diff:
                smallest_diff = diff
                closest_pair = pair

    return closest_pair

--------------------------------------------------
HumanEval/21

def rescale_to_unit(numbers):
    """
    Given a list of numbers, apply a linear transform to the list
    such that the smallest number will become 0 and the largest will become 1.
    """
    low = min(numbers)
    high = max(numbers)
    return [((x - low) / (high - low)) for x in numbers]

--------------------------------------------------
HumanEval/22

def filter_integers(my_list):
    return [x for x in my_list if type(x) == int]

--------------------------------------------------
HumanEval/23

def strlen(string: str) -> int:
    return len(string)

--------------------------------------------------
HumanEval/24

def largest_divisor(n):
    for i in range(n, 0, -1):
        if n % i == 0:
            return i

--------------------------------------------------
HumanEval/25

def factorize(n: int) -> List[int]:
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:
        factors.append(n)
    return factors

--------------------------------------------------
HumanEval/26

def remove_duplicates(numbers: List[int]) -> List[int]:
    return list(set(numbers))

--------------------------------------------------
HumanEval/27

def flip_case(string: str) -> str:
    return string.swapcase()

--------------------------------------------------
HumanEval/28

def concatenate(strings: List[str]) -> str:
    return "".join(strings)

--------------------------------------------------
HumanEval/29

def filter_by_prefix(my_list, prefix):
    return [s for s in my_list if s.startswith(prefix)]

--------------------------------------------------
HumanEval/30

def get_positive(my_list):
    return [x for x in my_list if x > 0]

--------------------------------------------------
HumanEval/31

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/32

def find_zero(xs: list):
    """
    Finds a zero of the polynomial defined by the given coefficients xs.
    The function returns only one zero, even if multiple zeros exist.
    The function only takes lists xs with an even number of coefficients and the largest non-zero coefficient, which guarantees a solution.
    """
    # Implement the find_zero function here
    return 0

--------------------------------------------------
HumanEval/33

def sort_third(l):
    return [val if i % 3 else sorted(val) for i, val in enumerate(l)]

--------------------------------------------------
HumanEval/34

def unique(my_list):
    return sorted(set(my_list))

--------------------------------------------------
HumanEval/35

def max_element(my_list):
    return max(my_list)

--------------------------------------------------
HumanEval/36

def fizz_buzz(n: int) -> int:
    count = 0
    for i in range(1, n):
        if i % 11 == 0 or i % 13 == 0:
            if '7' in str(i):
                count += 1
    return count

--------------------------------------------------
HumanEval/37

def sort_even(l):
    l_sorted = sorted(l[1::2])
    return [l_sorted[i//2] if i % 2 == 0 else l[i] for i in range(len(l))]

--------------------------------------------------
HumanEval/38

def decode_cyclic(s: str):
    """
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[-1:] + group[:-1]) if len(group) == 3 else group for group in groups]
    return "".join(groups)

--------------------------------------------------
HumanEval/39

def prime_fib(n: int) -> int:
    """
    Returns the n-th number that is both a Fibonacci number and a prime number.
    """
    fib_seq = []
    curr_fib = 1
    next_fib = 1
    for i in range(n):
        if is_prime(curr_fib):
            fib_seq.append(curr_fib)
        curr_fib, next_fib = next_fib, curr_fib + next_fib
    return fib_seq[n - 1]

def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/40

def triples_sum_to_zero(my_list):
    for i in range(len(my_list)):
        for j in range(i+1, len(my_list)):
            for k in range(j+1, len(my_list)):
                if my_list[i] + my_list[j] + my_list[k] == 0:
                    return True
    return False

--------------------------------------------------
HumanEval/41

def car_race_collision(n: int) -> int:
    """
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """
    # Calculate the number of collisions
    collisions = 0
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            elif i < j:
                collisions += 1
    return collisions

--------------------------------------------------
HumanEval/42

def incr_list(my_list):
    return [x + 1 for x in my_list]

--------------------------------------------------
HumanEval/43

def pairs_sum_to_zero(my_list):
    for i in range(len(my_list)):
        for j in range(i+1, len(my_list)):
            if my_list[i] + my_list[j] == 0:
                return True
    return False

--------------------------------------------------
HumanEval/44

def change_base(x: int, base: int) -> str:
    """Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.
    """
    return bin(x)[2:].zfill(base)

--------------------------------------------------
HumanEval/45

def triangle_area(a, h):
    return (a * h) / 2

--------------------------------------------------
HumanEval/46

def fib4(n: int) -> int:
    """The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fib4(0) -> 0
    fib4(1) -> 0
    fib4(2) -> 2
    fib4(3) -> 0
    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
    """
    if n <= 3:
        return 0
    elif n == 4:
        return 2
    
    # Initialize the first four elements of the sequence
    a, b, c, d = 0, 0, 2, 0
    
    for i in range(5, n+1):
        # Compute the next element in the sequence using the previous four elements
        a, b, c, d = b, c, d, a + b + c + d
    
    return d

--------------------------------------------------
HumanEval/47

def median(l):
    """Return median of elements in the list l.
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """
    sorted_l = sorted(l)
    if len(sorted_l) % 2 == 0:
        return (sorted_l[len(sorted_l) // 2 - 1] + sorted_l[len(sorted_l) // 2]) / 2
    else:
        return sorted_l[len(sorted_l) // 2]

--------------------------------------------------
HumanEval/48

def is_palindrome(text: str) -> bool:
    """
    Checks if given string is a palindrome

    :param text: The string to check
    :return: True if the string is a palindrome, False otherwise
    """
    return text == text[::-1]

--------------------------------------------------
HumanEval/49

def modp(n, p):
    return pow(2, n, p)

--------------------------------------------------
HumanEval/50

def decode_shift(s: str):
    """
    takes as input string encoded with encode_shift function. Returns decoded string.
    """
    return "".join([chr(((ord(ch) - 5 - ord("a")) % 26) + ord("a")) for ch in s])

--------------------------------------------------
HumanEval/51

def remove_vowels(text):
    vowels = ['a', 'e', 'i', 'o', 'u']
    return ''.join([char for char in text if char.lower() not in vowels])

--------------------------------------------------
HumanEval/52

def below_threshold(my_list, threshold):
    return all(element < threshold for element in my_list)

--------------------------------------------------
HumanEval/53

def add(x: int, y: int) -> int:
    """Add two numbers x and y"""
    return x + y

--------------------------------------------------
HumanEval/54

def same_chars(word1, word2):
    return sorted(word1) == sorted(word2)

--------------------------------------------------
HumanEval/55

def fib(n: int) -> int:
    """Return n-th Fibonacci number."""
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)

--------------------------------------------------
HumanEval/56

def correct_bracketing(brackets: str) -> bool:
    """
    Returns True if every opening bracket has a corresponding closing bracket.
    """
    stack = []
    for char in brackets:
        if char == "<":
            stack.append(char)
        elif char == ">":
            if len(stack) == 0:
                return False
            stack.pop()
    return len(stack) == 0

--------------------------------------------------
HumanEval/57

def monotonic(l):
    """Return True is list elements are monotonically increasing or decreasing.
    """
    if len(l) <= 1:
        return True
    return all(l[i] >= l[i-1] for i in range(1, len(l))) or all(l[i] <= l[i-1] for i in range(1, len(l)))

--------------------------------------------------
HumanEval/58

def common(l1, l2):
    return sorted(set(l1).intersection(l2))

--------------------------------------------------
HumanEval/59

def largest_prime_factor(n):
    if n <= 1:
        return n
    for i in range(int(n**0.5), 1, -1):
        if n % i == 0 and is_prime(i):
            return i
    return 1

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/60

def sum_to_n(n: int) -> int:
    return (n * (n + 1)) // 2

--------------------------------------------------
HumanEval/61

def correct_bracketing(brackets: str) -> bool:
    """
    Returns True if every opening bracket has a corresponding closing bracket.
    """
    stack = []
    for char in brackets:
        if char == "(":
            stack.append(char)
        elif char == ")":
            if not stack:
                return False
            stack.pop()
    return not stack

--------------------------------------------------
HumanEval/62

def derivative(xs):
    if len(xs) == 1:
        return [0]
    else:
        return [i * xs[i] for i in range(1, len(xs))]

--------------------------------------------------
HumanEval/63

def fibfib(n):
    if n <= 2:
        return 0
    else:
        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)

--------------------------------------------------
HumanEval/64

def vowels_count(word):
    vowels = ['a', 'e', 'i', 'o', 'u']
    count = 0
    for char in word:
        if char.lower() in vowels:
            count += 1
    return count

--------------------------------------------------
HumanEval/65

def circular_shift(x, shift):
    """Circular shift the digits of the integer x, shift the digits right by shift
    and return the result as a string.
    If shift > number of digits, return digits reversed.
    >>> circular_shift(12, 1)
    "21"
    >>> circular_shift(12, 2)
    "12"
    """
    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[-shift:] + s[:-shift]

--------------------------------------------------
HumanEval/66

def digit_sum(s):
    return sum([ord(c) for c in s if c.isupper()])

--------------------------------------------------
HumanEval/67

def fruit_distribution(s, n):
    apple, orange = map(int, s.split())
    return n - apple - orange

--------------------------------------------------
HumanEval/68

def pluck(arr):
    if not arr:
        return []
    even_values = [x for x in arr if x % 2 == 0]
    if not even_values:
        return []
    smallest_even_value = min(even_values)
    smallest_even_index = arr.index(smallest_even_value)
    return [smallest_even_value, smallest_even_index]

--------------------------------------------------
HumanEval/69

def search(lst):
    # create a dictionary to store the count of each integer
    freq = {}
    for num in lst:
        if num in freq:
            freq[num] += 1
        else:
            freq[num] = 1

    # find the maximum integer that satisfies the condition
    max_int = -1
    for num, count in freq.items():
        if num > 0 and count >= num and num > max_int:
            max_int = num

    return max_int

--------------------------------------------------
HumanEval/70

def strange_sort_list(lst):
    sorted_list = []
    while lst:
        current_min = min(lst)
        current_max = max(lst)
        sorted_list.extend([current_min, current_max])
        lst.remove(current_min)
        lst.remove(current_max)
    return sorted_list

--------------------------------------------------
HumanEval/71

def triangle_area(a, b, c):
    if a + b > c and b + c > a and a + c > b:
        area = (a * b * c) / 2
        return round(area, 2)
    else:
        return -1

--------------------------------------------------
HumanEval/72

def will_it_fly(q, w):
    return q == q[::-1] and sum(q) <= w

--------------------------------------------------
HumanEval/73

def smallest_change(arr):
    """
    Given an array arr of integers, find the minimum number of elements that
    need to be changed to make the array palindromic. A palindromic array is an array that
    is read the same backwards and forwards. In one change, you can change one element to any other element.

    For example:
    smallest_change([1,2,3,5,4,7,9,6]) == 4
    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1
    smallest_change([1, 2, 3, 2, 1]) == 0
    """
    # find the midpoint of the array
    mid = len(arr) // 2
    # initialize a variable to keep track of the number of changes
    changes = 0
    # loop through the first half of the array
    for i in range(mid):
        # check if the element at index i is not equal to the element at index len-i-1
        if arr[i] != arr[len-i-1]:
            # increment the changes variable
            changes += 1
            # set the element at index i to be equal to the element at index len-i-1
            arr[i] = arr[len-i-1]
    # return the number of changes
    return changes

--------------------------------------------------
HumanEval/74

def total_match(list1, list2):
    total_chars1 = sum(len(s) for s in list1)
    total_chars2 = sum(len(s) for s in list2)
    if total_chars1 < total_chars2:
        return list1
    elif total_chars1 > total_chars2:
        return list2
    else:
        return list1

--------------------------------------------------
HumanEval/75

def is_multiply_prime(a):
    if a < 1:
        return False
    for i in range(2, int(a**0.5) + 1):
        if a % i == 0 and is_prime(i) and is_prime(a//i):
            return True
    return False

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/76

def is_simple_power(x, n):
    return x == n ** int(x / n)

--------------------------------------------------
HumanEval/77

def iscube(a):
    return a**(1/3).is_integer()

--------------------------------------------------
HumanEval/78

def hex_key(num):
    prime_digits = set([2, 3, 5, 7, 11, 13, 17, 19])
    num = num.upper()
    count = 0
    for char in num:
        if char in 'ABCDEF' and int(char, 16) in prime_digits:
            count += 1
    return count

--------------------------------------------------
HumanEval/79

def decimal_to_binary(decimal):
    binary = ""
    while decimal != 0:
        binary = str(decimal % 2) + binary
        decimal //= 2
    return "db" + binary + "db"

--------------------------------------------------
HumanEval/80

def is_happy(s):
    if len(s) < 3:
        return False
    for i in range(len(s) - 2):
        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:
            return False
    return True

--------------------------------------------------
HumanEval/81

def numerical_letter_grade(grades):
    return [['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'D+', 'D', 'D-', 'E'][min(12, max(0, (int(grade - 3) / 2)))] for grade in grades]

--------------------------------------------------
HumanEval/82

def prime_length(string):
    return len(string) in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

--------------------------------------------------
HumanEval/83

def starts_one_ends(n):
    count = 0
    for i in range(10**(n-1), 10**n):
        if str(i)[0] == '1' or str(i)[-1] == '1':
            count += 1
    return count

--------------------------------------------------
HumanEval/84

def solve(N):
    return bin(sum(int(i) for i in str(N)))[2:]

--------------------------------------------------
HumanEval/85

def add(lst):
    result = 0
    for i in range(len(lst)):
        if i % 2 == 1 and lst[i] % 2 == 0:
            result += lst[i]
    return result

--------------------------------------------------
HumanEval/86

def anti_shuffle(s):
    words = s.split()
    ordered_words = []
    for word in words:
        ordered_word = "".join(sorted(word))
        ordered_words.append(ordered_word)
    return " ".join(ordered_words)

--------------------------------------------------
HumanEval/87

def get_row(lst, x):
    coordinates = []
    for i in range(len(lst)):
        for j in range(len(lst[i])):
            if lst[i][j] == x:
                coordinates.append((i, j))
    return sorted(coordinates, key=lambda x: (x[0], -x[1]))

--------------------------------------------------
HumanEval/88

def sort_array(arr):
    if sum(arr[0], arr[-1]) % 2 == 0:
        return sorted(arr, reverse=True)
    else:
        return sorted(arr)

--------------------------------------------------
HumanEval/89

def encrypt(s):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    new_alphabet = alphabet[2:] + alphabet[:2]
    table = str.maketrans(alphabet, new_alphabet)
    return s.translate(table)

--------------------------------------------------
HumanEval/90

def next_smallest(my_list):
    if len(my_list) < 2:
        return None
    sorted_list = sorted(my_list)
    smallest = sorted_list[0]
    for i in range(1, len(sorted_list)):
        if sorted_list[i] != smallest:
            return sorted_list[i]
    return None

--------------------------------------------------
HumanEval/91

def is_bored(string):
    count = 0
    for sentence in string.split('.')[:-1]:
        if sentence.startswith('I'):
            count += 1
    return count

--------------------------------------------------
HumanEval/92

def any_int(x, y, z):
    if x == y + z or y == x + z or z == x + y:
        return True
    else:
        return False

--------------------------------------------------
HumanEval/93

def encode(message):
    vowels = ['a', 'e', 'i', 'o', 'u']
    encoded = ''
    for char in message:
        if char.isalpha():
            if char.islower():
                encoded += char.upper()
            else:
                encoded += char.lower()
        else:
            encoded += char
    
    for i, char in enumerate(encoded):
        if char in vowels:
            encoded = encoded[:i] + chr(ord(char) + 2) + encoded[i+1:]
    
    return encoded

--------------------------------------------------
HumanEval/94

def get_largest_prime_sum(my_list):
    # find the largest prime number in the list
    largest_prime = None
    for i in my_list:
        if is_prime(i) and (largest_prime is None or i > largest_prime):
            largest_prime = i

    # return the sum of its digits
    if largest_prime is not None:
        return sum(int(digit) for digit in str(largest_prime))
    else:
        return 0

def is_prime(n):
    # check if n is a prime number
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/95

def check_dict_case(my_dict):
    if not my_dict:
        return False
    first_key = list(my_dict.keys())[0]
    return all(key.islower() or key.isupper() for key in my_dict.keys())

--------------------------------------------------
HumanEval/96

def count_up_to(n):
    prime_numbers = []
    for i in range(2, n+1):
        is_prime = True
        for j in range(2, int(i**0.5) + 1):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            prime_numbers.append(i)
    return prime_numbers

--------------------------------------------------
HumanEval/97

def multiply(a, b):
    return int(str(a)[-1]) * int(str(b)[-1])

--------------------------------------------------
HumanEval/98

def count_upper(s):
    count = 0
    for i, c in enumerate(s):
        if i % 2 == 0 and c.isupper():
            count += 1
    return count

--------------------------------------------------
HumanEval/99

def closest_integer(value):
    return round(float(value))

--------------------------------------------------
HumanEval/100

def make_a_pile(n):
    stones = [n]
    while n > 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = (n + 1) // 2
        stones.append(n)
    return stones[::-1]

--------------------------------------------------
HumanEval/101

def words_string(my_string):
    return my_string.split()

--------------------------------------------------
HumanEval/102

def choose_num(x, y):
    # find the biggest even number in the range [x, y] inclusive
    for i in range(y, x-1, -1):
        if i % 2 == 0:
            return i
    return -1

--------------------------------------------------
HumanEval/103

def rounded_avg(n, m):
    if n > m:
        return -1
    sum = 0
    for i in range(n, m+1):
        sum += i
    average = int(sum / (m-n+1))
    binary_string = bin(average)[2:]
    return "0b" + binary_string

--------------------------------------------------
HumanEval/104

def unique_digits(x):
    """Given a list of positive integers x. return a sorted list of all 
    elements that hasn't any even digit.

    Note: Returned list should be sorted in increasing order.
    
    For example:
    >>> unique_digits([15, 33, 1422, 1])
    [1, 15, 33]
    >>> unique_digits([152, 323, 1422, 10])
    []
    """
    result = []
    for i in x:
        if not any(int(digit) % 2 == 0 for digit in str(i)):
            result.append(i)
    return sorted(result)

--------------------------------------------------
HumanEval/105

def by_length(arr):
    arr.sort()
    arr.reverse()
    return ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"][arr]

--------------------------------------------------
HumanEval/106

def f(n):
    result = []
    for i in range(1, n+1):
        if i % 2 == 0:
            factorial = 1
            for j in range(1, i+1):
                factorial *= j
            result.append(factorial)
        else:
            sum = 0
            for j in range(1, i+1):
                sum += j
            result.append(sum)
    return result

--------------------------------------------------
HumanEval/107

def even_odd_palindrome(n):
    even_count = 0
    odd_count = 0
    for i in range(1, n+1):
        if is_palindrome(i):
            if i % 2 == 0:
                even_count += 1
            else:
                odd_count += 1
    return (even_count, odd_count)

def is_palindrome(n):
    return str(n) == str(n)[::-1]

--------------------------------------------------
HumanEval/108

def count_nums(arr):
    count = 0
    for num in arr:
        if sum(int(digit) for digit in str(num)) > 0:
            count += 1
    return count

--------------------------------------------------
HumanEval/109

def move_one_ball(arr):
        if len(arr) == 0:
            return True
        else:
            arr.sort()
            for i in range(len(arr)-1):
                if arr[i] > arr[i+1]:
                    return False
            return True

--------------------------------------------------
HumanEval/110

def exchange(lst1, lst2):
    # Check if all elements in lst1 are even
    if all(x % 2 == 0 for x in lst1):
        return "YES"
    # Check if there are any even numbers in lst2
    elif any(x % 2 == 0 for x in lst2):
        return "NO"
    # Check if it is possible to exchange elements between lst1 and lst2 to make all elements of lst1 even
    else:
        # Sort both lists
        lst1.sort()
        lst2.sort()
        # Initialize variables to keep track of the current index in both lists
        i = 0
        j = 0
        # Loop through both lists and check if it is possible to exchange elements to make all elements of lst1 even
        while i < len(lst1) and j < len(lst2):
            if lst1[i] % 2 == 0 and lst2[j] % 2 != 0:
                # If the current element in lst1 is even and the current element in lst2 is odd, exchange elements
                lst1[i], lst2[j] = lst2[j], lst1[i]
                i += 1
                j += 1
            elif lst1[i] % 2 != 0 and lst2[j] % 2 == 0:
                # If the current element in lst1 is odd and the current element in lst2 is even, exchange elements
                lst1[i], lst2[j] = lst2[j], lst1[i]
                i += 1
                j += 1
            else:
                # If the current elements in both lists are not compatible for exchange, move on to the next element in lst1
                i += 1
        # After looping through both lists, check if all elements of lst1 are even
        if all(x % 2 == 0 for x in lst1):
            return "YES"
        else:
            return "NO"

--------------------------------------------------
HumanEval/111

def histogram(string):
    letters = string.split()
    counts = {}
    for letter in letters:
        if letter not in counts:
            counts[letter] = 1
        else:
            counts[letter] += 1
    return counts

--------------------------------------------------
HumanEval/112

<b>def reverse_delete(s, c):</b>
    <b>result = ""</b>
    <b>for char in s:</b>
        <b>if char not in c:</b>
            <b>result += char</b>
    <b>return (result, result == result[::-1])</b>

--------------------------------------------------
HumanEval/113

def odd_count(my_list):
    return ["the number of odd elements {} in the string {} of the input.".format(str(len([x for x in s if int(x) % 2 == 1])), i) for i, s in enumerate(my_list)]

--------------------------------------------------
HumanEval/114

def minSubArraySum(nums):
    """
    Given an array of integers nums, find the minimum sum of any non-empty sub-array
    of nums.
    Example
    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1
    minSubArraySum([-1, -2, -3]) == -6
    """
    # initialize a variable to store the minimum sum
    min_sum = float('inf')
    # loop through the array and calculate the sum of each sub-array
    for i in range(len(nums)):
        for j in range(i, len(nums)):
            sub_array_sum = sum(nums[i:j+1])
            min_sum = min(min_sum, sub_array_sum)
    return min_sum

--------------------------------------------------
HumanEval/115

def max_fill(grid, capacity):
    rows = len(grid)
    cols = len(grid[0])
    water = 0
    buckets = 0

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1:
                water += 1
                if water == capacity:
                    buckets += 1
                    water = 0

    if water > 0:
        buckets += 1

    return buckets

--------------------------------------------------
HumanEval/116

def sort_array(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))

--------------------------------------------------
HumanEval/117

def select_words(s, n):
    words = s.split()
    return [word for word in words if len(word) == n]

--------------------------------------------------
HumanEval/118

def get_closest_vowel(word):
    vowels = "aeiou"
    for i in range(len(word)-1, 0, -1):
        if word[i] in vowels:
            return word[i]
    return ""

--------------------------------------------------
HumanEval/119

def match_parens(lst):
    open_count = 0
    for char in lst:
        if char == '(':
            open_count += 1
        elif char == ')':
            open_count -= 1
        if open_count < 0:
            return 'No'
    return 'Yes' if open_count == 0 else 'No'

--------------------------------------------------
HumanEval/120

def maximum(arr, k):
    return sorted(arr, reverse=True)[:k]

--------------------------------------------------
HumanEval/121

def solution(lst):
    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)

--------------------------------------------------
HumanEval/122

def add_elements(arr, k):
    # sort the array in ascending order
    arr.sort()
    # initialize the sum to 0
    sum = 0
    # loop through the first k elements of the array
    for i in range(k):
        # extract the digit from the current element
        digit = arr[i] // 10
        # check if the digit is less than or equal to 2
        if digit <= 2:
            # add the current element to the sum
            sum += arr[i]
    # return the sum
    return sum

--------------------------------------------------
HumanEval/123

def get_odd_collatz(n):
    if n <= 0:
        raise ValueError("n should be a positive integer.")
    
    collatz_list = [n]
    while n != 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
        collatz_list.append(n)
    
    return sorted([x for x in collatz_list if x % 2 != 0])

--------------------------------------------------
HumanEval/124

import re

def valid_date(date):
    """
    Validates a given date string and returns True if the date is valid, otherwise False.

    The date is valid if all of the following rules are satisfied:
    1. The date string is not empty.
    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
    3. The months should not be less than 1 or higher than 12.
    4. The date should be in the format: mm-dd-yyyy
    """
    if not date:
        return False
    match = re.match(r'^(\d{2})-(\d{2})-(\d{4})$', date)
    if not match:
        return False
    month, day, year = map(int, match.groups())
    if month < 1 or month > 12:
        return False
    if day < 1 or day > 31:
        return False
    if month in [4, 6, 9, 11] and day == 31:
        return False
    if month == 2 and (day < 1 or day > 29):
        return False
    if year % 4 == 0 and month == 2 and day == 30:
        return False
    return True
```

--------------------------------------------------
HumanEval/125

<b>def split_words(txt):</b>
    <b>if ' ' in txt:</b>
        <b>return txt.split()</b>
    <b>elif ',' in txt:</b>
        <b>return txt.split(',')</b>
    <b>else:</b>
        <b>result = 0</b>
        <b>for char in txt:</b>
            <b>if ord(char) % 2 == 1:</b>
                <b>result += 1</b>
        <b>return result</b>

--------------------------------------------------
HumanEval/126

def is_sorted(my_list):
    if len(my_list) == 1:
        return True
    else:
        for i in range(len(my_list) - 1):
            if my_list[i] > my_list[i + 1]:
                return False
            elif my_list[i] == my_list[i + 1]:
                if my_list.count(my_list[i]) > 1:
                    return False
        return True

--------------------------------------------------
HumanEval/127

def intersection(interval1, interval2):
    start = max(interval1[0], interval2[0])
    end = min(interval1[1], interval2[1])
    if start > end:
        return "NO"
    length = end - start + 1
    if length > 1 and all(length % i != 0 for i in range(2, int(length ** 0.5) + 1)):
        return "YES"
    return "NO"

--------------------------------------------------
HumanEval/128

def prod_signs(arr):
    if not arr:
        return None
    mult = 1
    for num in arr:
        if num < 0:
            mult *= -1
    return sum(abs(num) * mult for num in arr)

--------------------------------------------------
HumanEval/129

import heapq

def min_path(grid, k):
    # Initialize the heap with the first element of each row
    heap = [(grid[0][0], 0, 0)]
    # Initialize the visited matrix with False
    visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]
    # Initialize the result list
    result = []

    while len(heap) > 0:
        # Pop the smallest element from the heap
        value, row, col = heapq.heappop(heap)
        # If the current position is not visited and the path length is less than k
        if not visited[row][col] and len(result) < k:
            # Add the current value to the result list
            result.append(value)
            # Mark the current position as visited
            visited[row][col] = True
            # Loop through the neighbors of the current position
            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:
                # If the neighbor is within the grid and not visited
                if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and not visited[r][c]:
                    # Add the neighbor to the heap
                    heapq.heappush(heap, (grid[r][c], r, c))

    return result

def main():
    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    k = 3
    print(min_path(grid, k))

if __name__ == "__main__":
    main()

--------------------------------------------------
HumanEval/130

def tribonacci_sequence(n):
    if n == 1:
        return [1]
    elif n == 2:
        return [1, 3]
    else:
        seq = [1, 3]
        for i in range(2, n):
            seq.append(seq[i-1] + seq[i-2] + seq[i+1])
        return seq

--------------------------------------------------
HumanEval/131

def digits(n):
    product = 1
    while n > 0:
        if n % 2 == 1:
            product *= n % 10
        n //= 10
    return product

--------------------------------------------------
HumanEval/132

def is_nested(string):
    stack = []
    for char in string:
        if char == '[':
            stack.append(char)
        elif char == ']':
            if len(stack) == 0:
                return False
            stack.pop()
    return len(stack) != 0

--------------------------------------------------
HumanEval/133

def sum_squares(lst):
    return sum(int(x)**2 for x in lst)

--------------------------------------------------
HumanEval/134

def check_if_last_char_is_a_letter(txt):
    if not txt:
        return False
    last_char = txt[-1]
    return last_char.isalpha() and last_char not in "abcdefghijklmnopqrstuvwxyz"

--------------------------------------------------
HumanEval/135

def can_arrange(arr):
    for i in range(len(arr) - 1, -1, -1):
        if arr[i] <= arr[i - 1]:
            return i
    return -1

--------------------------------------------------
HumanEval/136

def largest_smallest_integers(lst):
    largest = None
    smallest = None
    for num in lst:
        if num < 0 and (largest is None or num > largest):
            largest = num
        elif num > 0 and (smallest is None or num < smallest):
            smallest = num
    return (largest, smallest)

--------------------------------------------------
HumanEval/137

def compare_one(a, b):
    if type(a) is str:
        a = float(a.replace(",", "."))
    if type(b) is str:
        b = float(b.replace(",", "."))
    if a == b:
        return None
    return a if a > b else b

--------------------------------------------------
HumanEval/138

def is_equal_to_sum_even(n):
    return n % 2 == 0 and any(n == i + j + k + l for i in range(2, int(n**0.5) + 1, 2) for j in range(2, int(n**0.5) + 1, 2) for k in range(2, int(n**0.5) + 1, 2) for l in range(2, int(n**0.5) + 1, 2))

--------------------------------------------------
HumanEval/139

def special_factorial(n):
    if n == 1:
        return 1
    else:
        return n * special_factorial(n-1)

--------------------------------------------------
HumanEval/140

def fix_spaces(text):
    return text.replace(" ", "_").replace("  ", "-")

--------------------------------------------------
HumanEval/141

def file_name_check(file_name):
    if len([c for c in file_name if c.isdigit()]) > 3:
        return 'No'
    if '.' not in file_name:
        return 'No'
    if len(file_name.split('.')[0]) == 0:
        return 'No'
    if file_name.split('.')[1] not in ['txt', 'exe', 'dll']:
        return 'No'
    return 'Yes'

--------------------------------------------------
HumanEval/142

def sum_squares(lst):
    result = 0
    for i, x in enumerate(lst):
        if i % 3 == 0:
            result += x * x
        elif i % 4 == 0:
            result += x * x * x
        else:
            result += x
    return result

--------------------------------------------------
HumanEval/143

def words_in_sentence(sentence):
    words = sentence.split()
    prime_words = []
    for word in words:
        if is_prime(len(word)):
            prime_words.append(word)
    return " ".join(prime_words)

def is_prime(n):
    if n == 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/144

def simplify(x, n):
    x_num, x_denom = map(int, x.split("/"))
    n_num, n_denom = map(int, n.split("/"))
    return (x_num * n_num) % (x_denom * n_denom) == 0

--------------------------------------------------
HumanEval/145

def order_by_points(nums):
    return sorted(nums, key=lambda x: (sum(int(digit) for digit in str(abs(x))), x))

--------------------------------------------------
HumanEval/146

def special_filter(nums):
    count = 0
    for num in nums:
        if num > 10 and num % 10 in [1, 3, 5, 7, 9] and num // 100 in [1, 3, 5, 7, 9]:
            count += 1
    return count

--------------------------------------------------
HumanEval/147

def get_max_triples(n):
        a = [i * i - i + 1 for i in range(1, n + 1)]
        count = 0
        for i in range(len(a)):
            for j in range(i + 1, len(a)):
                for k in range(j + 1, len(a)):
                    if a[i] + a[j] + a[k] % 3 == 0:
                        count += 1
        return count

    n = 5
    print(get_max_triples(n))

--------------------------------------------------
HumanEval/148

def between_planets(planet1, planet2):
    planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]
    index1 = planets.index(planet1)
    index2 = planets.index(planet2)
    if index1 > index2:
        index1, index2 = index2, index1
    return tuple(planets[index1+1:index2])

def test_between_planets():
    assert between_planets("Jupiter", "Neptune") == ("Saturn", "Uranus")
    assert between_planets("Earth", "Mercury") == ("Venus")
    assert between_planets("Mercury", "Uranus") == ("Venus", "Earth", "Mars", "Jupiter", "Saturn")

--------------------------------------------------
HumanEval/149

def list_sort(my_list):
    return sorted(my_list, key=lambda x: (len(x), x))

--------------------------------------------------
HumanEval/150

def x_or_y(n, x, y):
    if is_prime(n):
        return x
    else:
        return y

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

--------------------------------------------------
HumanEval/151

def double_the_difference(lst):
    result = 0
    for num in lst:
        if num % 2 != 0 and num > 0 and num == int(num):
            result += num ** 2
    return result

--------------------------------------------------
HumanEval/152

def compare(scores, guesses):
    return [abs(score - guess) for score, guess in zip(scores, guesses)]

--------------------------------------------------
HumanEval/153

def strongest_extension(class_name, extensions):
    max_strength = None
    strongest_extension = None
    for extension in extensions:
        cap = sum(1 for c in extension if c.isupper())
        sm = sum(1 for c in extension if c.islower())
        strength = cap - sm
        if max_strength is None or strength > max_strength:
            max_strength = strength
            strongest_extension = extension
    return f"{class_name}.{strongest_extension}"

--------------------------------------------------
HumanEval/154

def cycpattern_check(word1, word2):
    return any(word2 in word1[i:] for i in range(len(word1)))

--------------------------------------------------
HumanEval/155

def even_odd_count(n):
    even = 0
    odd = 0
    while n:
        if n % 2 == 0:
            even += 1
        else:
            odd += 1
        n //= 10
    return (even, odd)

--------------------------------------------------
HumanEval/156

def int_to_mini_roman(number):
    """
    Given a positive integer, obtain its roman numeral equivalent as a string,
    and return it in lowercase.
    Restrictions: 1 <= num <= 1000

    Examples:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """
    num = str(number)
    roman = ''
    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']
    for i in range(len(values)):
        while num[0] == '1':
            roman += numerals[i]
            num = num[1:]
        if num[0] == '0':
            num = num[1:]
    return roman

--------------------------------------------------
HumanEval/157

def right_angle_triangle(a, b, c):
    return (a**2 + b**2 == c**2) or (b**2 + c**2 == a**2) or (c**2 + a**2 == b**2)

--------------------------------------------------
HumanEval/158

def find_max(words):
    if not words:
        return None
    max_word = words[0]
    for word in words:
        if len(set(word)) > len(set(max_word)):
            max_word = word
        elif len(set(word)) == len(set(max_word)):
            if word < max_word:
                max_word = word
    return max_word

--------------------------------------------------
HumanEval/159

def eat(number, need, remaining):
    total = number + need
    if total > remaining:
        return [remaining, 0]
    else:
        return [total, remaining - total]

--------------------------------------------------
HumanEval/160

def do_algebra(operator, operand):
    result = operand[0]
    for i in range(len(operator)):
        op = operator[i]
        if op == '+':
            result += operand[i+1]
        elif op == '-':
            result -= operand[i+1]
        elif op == '*':
            result *= operand[i+1]
        elif op == '//':
            result //= operand[i+1]
        elif op == '**':
            result **= operand[i+1]
        else:
            raise ValueError("Invalid operator")
    return result

--------------------------------------------------
HumanEval/161

def solve(s):
    res = ""
    for c in s:
        if c.isalpha():
            if c.islower():
                res += c.upper()
            else:
                res += c.lower()
        else:
            res += c
    if not res:
        return s[::-1]
    return res

--------------------------------------------------
HumanEval/162

import hashlib

def string_to_md5(text):
    if text == '':
        return None
    return hashlib.md5(text.encode('utf-8')).hexdigest()

--------------------------------------------------
HumanEval/163

def generate_integers(a, b):
    if a > b:
        a, b = b, a
    even_digits = []
    for i in range(a, b+1):
        if i % 2 == 0:
            even_digits.append(i)
    return even_digits

--------------------------------------------------
